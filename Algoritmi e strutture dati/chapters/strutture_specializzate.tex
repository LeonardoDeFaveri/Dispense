\chapter{Strutture dati specializzate}
Finora abbiamo esaminato una serie di \emph{strutture dati} e per ciascuna
ne abbiamo anche analizzato il costo delle operazioni. È possibile però
definire \emph{strutture dati speciali}, o per meglio dire \q{\emph{specializzate}},
nelle quali vengono implementate soltanto alcune delle operazioni e per questo
motivo quelle implementazioni possono essere realizzare in modo più efficiente.

In questo capitolo vedremo due esempi di \emph{strutture specializzate}: le
\emph{code a priorità} e gli \emph{insiemi disgiunti}.

\section{Code a priorità}
\begin{definition}[Coda a priorità]
    Una coda a priorità è una struttura dati astratta, simile a una coda, in
    cui ogni elemento possiede un valore che ne indica la \q{priorità} e che
    viene usato per stabilire l'ordine di estrazione degli elementi dalla
    struttura.
\end{definition}

\noindent
Esistono due tipi di \emph{code a priorità} (\emph{priority queue}):
\begin{itemize}
    \item \emph{Min-priority queue}: l'estrazione avviene per valori crescenti
    di priorità;
    \item \emph{Max-priority queue}: l'estrazione avviene per valori decrescenti
    di priorità;
\end{itemize}

\paragraph{Specifica}
\begin{code}{MINPRIORITYQUEUE}
    \com{Crea una \emph{coda a priorità} con capacità $n$}
    \bc{PRIORITYQUEUE} PriorityQueue(\bc{int} n)
    \nl\com{Restituisce \bc{true} se la \emph{coda a priorità} è vuota}
    \bc{boolean} isEmpty()
    \nl\com{Restituisce l'elemento minimo di una \emph{coda a priorità} non vuota}
    \bc{ITEM} min()
    \nl\com{Rimuove e restituisce l’elemento minimo di una \emph{coda a priorità} non vuota}
    \bc{deleteMin()}
    \nl\com{Inserisce l'elemento $x$ con priorità $p$ nella \emph{coda a priorità} e restituisce}
    \com{un oggetto \bc{PRIORITYITEM} che identifica $x$ all'interno della \emph{coda}}
    \bc{PRIORITYITEM} insert(\bc{ITEM} x, \bc{int} p)
    \nl\com{Diminuisce la priorità dell’oggetto identificato da $y$ portandola a $p$}
    decrease(\bc{PRIORITYITEM} y, \bc{int} p)
\end{code}
\begin{note}
    La specifica di una \emph{max-priority queue} è uguale, ma invece delle
    operazioni \texttt{min}, \texttt{deleteMin} e \texttt{decrease} ha
    \texttt{max}, \texttt{deleteMax} e \texttt{increase}.
\end{note}\noindent
Utilizzando le \emph{strutture dati} viste finora possiamo calcolare i seguenti
costi:
\begin{table}[h!]
\resizebox{\linewidth}{!}{
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{Operazione} & $\begin{array}[c]{c}
        \textbf{Lista}\\
        \textbf{Vettore non ordinato}
    \end{array}$ & \textbf{Lista ordinata} & \textbf{Vettore ordinato} &
    \textbf{Albero Red-Black}\\
    \hline
    \textbf{min} & $O(n)$ & $O(1)$ & $O(1)$ & $O(\log n)$\\
    \hline
    \textbf{deleteMin} & $O(n)$ & $O(1)$ & $O(n)$ & $O(\log n)$\\
    \hline
    \textbf{insert} & $O(n)$ & $O(n)$ & $O(n)$ & $O(\log n)$\\
    \hline
    \textbf{decrease} & $O(n)$ & $O(n)$ & $O(\log n)$ & $O(\log n)$\\
    \hline
\end{tabular}}
\end{table}

\noindent
È possibile fare meglio di così?

La risposta è sì, utilizzando uno \emph{heap}, una \emph{struttura dati speciale}
che associa i vantaggi di un \emph{albero}, cioè la \emph{complessità} $O(\log n)$,
e la memorizzazione efficiente ottenibile con i normali vettori.

\subsection{Heap}
La \emph{struttura dati} dello \emph{heap} fu inventata da J. Williams nel
1964 con l'obiettivo di realizzare l'algoritmo di ordinamento \emph{HeapSort}.
Vediamo come si è arrivati all'ideazione dello \emph{heap}.

\bigskip\noindent
Consideriamo un \emph{albero binario perfetto} come il seguente:
\begin{figure}[h!]
    \centering
    \begin{graph}
        \node[main] (0) {$a$};
        \node[main] (1) [below left of=0, xshift=-10, yshift=-20] {$b$};
        \node[main] (2) [below right of=0, xshift=10, yshift=-20] {$c$};
        \node[main] (3) [below left of=1, xshift=10, yshift=-20] {$d$};
        \node[main] (4) [below right of=1, xshift=-10, yshift=-20] {$e$};
        \node[main] (5) [below left of=2, xshift=10, yshift=-20] {$f$};
        \node[main] (6) [below right of=2, xshift=-10, yshift=-20] {$g$};
      
        \path[-]  (0) edge (1)
                  (0) edge (2)
                  (1) edge (3)
                  (1) edge (4)
                  (2) edge (5)
                  (2) edge (6);
    \end{graph}
    \caption{\emph{Albero binario perfetto}}
\end{figure}

\noindent
Tutte le \emph{foglie} sono alla stessa \emph{profondità} $h$ e tutti i \emph{nodi}
interni hanno \emph{grado uscente} pari a 2. Se $n$ è il numero di \emph{nodi},
l'\emph{altezza} vale $h=\lfloor\log n\rfloor$ e, data l'\emph{altezza} $h$, il
numero di \emph{nodi} è $n=2^{h+1}-1$.

\bigskip\noindent
Cosa accade se si aggiunge un \emph{nodo}?

Ovviamente l'\emph{albero} non può più essere definito \emph{perfetto}. Supponiamo
però di \q{accatastare} tutti i nuovi \emph{nodi} a partire da sinistra. In questo
modo otteniamo un \emph{albero binario completo} nel quale tutte le \emph{foglie}
hanno \emph{profondità} $h$ o $h-1$, i \emph{nodi} al \emph{livello} $h$ sono
\q{accatastati} a sinistra e tutti \emph{nodi} interni hanno \emph{grado uscente}
pari a 2 eccetto al più uno. Come prima poi, per l'\emph{altezza} $h$ vale $h=\lfloor
\log n\rfloor$.

\begin{figure}[ht]
    \centering
    \begin{graph}
        \node[main] (0) {$a$};
        \node[main] (1) [below left of=0, xshift=-10, yshift=-20] {$b$};
        \node[main] (2) [below right of=0, xshift=10, yshift=-20] {$c$};
        \node[main] (3) [below left of=1, xshift=10, yshift=-20] {$d$};
        \node[main] (4) [below right of=1, xshift=-10, yshift=-20] {$e$};
        \node[main] (5) [below left of=2, xshift=10, yshift=-20] {$f$};
      
        \path[-]  (0) edge (1)
                  (0) edge (2)
                  (1) edge (3)
                  (1) edge (4)
                  (2) edge (5);
    \end{graph}
    \caption{\emph{Albero completo}}
\end{figure}
\begin{definition}[Albero min-heap]
    Un albero min-heap è un albero binario completo tale per cui il valore
    memorizzato in ogni nodo è minore dei valori memorizzati nei suoi figli.
\end{definition}
\begin{definition}[Albero max-heap]
    Un albero max-heap è un albero binario completo tale per  cui il valore
    memorizzato in ogni nodo è maggiore dei valori memorizzati nei suoi figli.
\end{definition}

\begin{figure}[th]
    \centering
    \begin{graph}
        \node[main] (0) {$16$};
        \node[main] (1) [below left of=0, xshift=-20, yshift=-20] {$14$};
        \node[main] (2) [below right of=0, xshift=20, yshift=-20] {$10$};
        \node[main] (3) [below left of=1, xshift=0, yshift=-20] {$8$};
        \node[main] (4) [below right of=1, xshift=0, yshift=-20] {$7$};
        \node[main] (5) [below left of=2, xshift=0, yshift=-20] {$9$};
        \node[main] (6) [below right of=2, xshift=0, yshift=-20] {$3$};
        \node[main] (7) [below left of=3, xshift=20, yshift=-20] {$2$};
        \node[main] (8) [below right of=3, xshift=-20, yshift=-20] {$4$};
        \node[main] (9) [below left of=4, xshift=20, yshift=-20] {$1$};
      
        \path[-]  (0) edge (1)
                  (0) edge (2)
                  (1) edge (3)
                  (1) edge (4)
                  (2) edge (5)
                  (2) edge (6)
                  (3) edge (7)
                  (3) edge (8)
                  (4) edge (9);
    \end{graph}
    \caption{\emph{Albero max-heap}}
\end{figure}\noindent
Un \emph{albero heap} non impone un ordinamento totale tra i \emph{figli} di un
\emph{nodo}, bensì definisce un \emph{ordinamento parziale} e quindi soddisfa
le seguenti tre proprietà:
\begin{itemize}
    \item \emph{Riflessività}: ogni \emph{nodo} è maggiore o uguale a se stesso;
    \item \emph{Antisimmetria}: se $n\geq m$ e $m\geq n$, allora $m=n$;
    \item \emph{Transitività}: se $n\geq m$ e $m\geq r$, allora $n\geq r$;
\end{itemize}
\begin{note}
    Un ordinamento parziale è una nozione più debole, ma più facile da
    realizzare.
\end{note}

\paragraph{Memorizzazione}
Un \emph{albero heap} può essere rappresentato mediante un \emph{vettore heap},
cioè un vettore nel quale, se la \emph{radice} è in posizione 1, il \emph{padre}
e i \emph{figli sinistro} e \emph{destro} di un \emph{nodo} in posizione $i$ si
trovano rispettivamente alle posizioni $p(i)=\lfloor i/2\rfloor$, $l(i)=2i$ e $r(i)=2i+i$.

Se invece la \emph{radice} è in posizione 0, gli indici del \emph{padre} e dei
\emph{figli} diventano rispettivamente $p(i)=\lfloor(i-1)/2\rfloor$, $l(i)=2i+1$
e $r(i)=2i+2$.

\begin{figure}[h!]
    \centering
    \subfloat[\emph{Albero heap} con \emph{radice} in 1]
    {
        \resizebox*{0.48\textwidth}{!}{
            \begin{graph}
                \node[main, label={$A[1]$}] (0) {$16$};
                \node[main, label={$A[2]$}] (1) [below left of=0, xshift=-20, yshift=-20] {$14$};
                \node[main, label={$A[3]$}] (2) [below right of=0, xshift=20, yshift=-20] {$10$};
                \node[main, label={$A[4]$}] (3) [below left of=1, xshift=0, yshift=-20] {$8$};
                \node[main, label={$A[5]$}] (4) [below right of=1, xshift=0, yshift=-20] {$7$};
                \node[main, label={$A[6]$}] (5) [below left of=2, xshift=0, yshift=-20] {$9$};
                \node[main, label={$A[7]$}] (6) [below right of=2, xshift=0, yshift=-20] {$3$};
                \node[main, label=below:{$A[8]$}] (7) [below left of=3, xshift=20, yshift=-20] {$2$};
                \node[main, label=below:{$A[9]$}] (8) [below right of=3, xshift=-20, yshift=-20] {$4$};
                \node[main, label=below:{$A[10]$}] (9) [below left of=4, xshift=20, yshift=-20] {$1$};
              
                \path[-]  (0) edge (1)
                          (0) edge (2)
                          (1) edge (3)
                          (1) edge (4)
                          (2) edge (5)
                          (2) edge (6)
                          (3) edge (7)
                          (3) edge (8)
                          (4) edge (9);
            \end{graph}
        }
    }
    \hfill
    \subfloat[\emph{Albero heap} con \emph{radice} in 0]
    {
        \resizebox*{0.48\textwidth}{!}{
            \begin{graph}
                \node[main, label={$A[0]$}] (0) {$16$};
                \node[main, label={$A[1]$}] (1) [below left of=0, xshift=-20, yshift=-20] {$14$};
                \node[main, label={$A[2]$}] (2) [below right of=0, xshift=20, yshift=-20] {$10$};
                \node[main, label={$A[3]$}] (3) [below left of=1, xshift=0, yshift=-20] {$8$};
                \node[main, label={$A[4]$}] (4) [below right of=1, xshift=0, yshift=-20] {$7$};
                \node[main, label={$A[5]$}] (5) [below left of=2, xshift=0, yshift=-20] {$9$};
                \node[main, label={$A[6]$}] (6) [below right of=2, xshift=0, yshift=-20] {$3$};
                \node[main, label=below:{$A[7]$}] (7) [below left of=3, xshift=20, yshift=-20] {$2$};
                \node[main, label=below:{$A[8]$}] (8) [below right of=3, xshift=-20, yshift=-20] {$4$};
                \node[main, label=below:{$A[9]$}] (9) [below left of=4, xshift=20, yshift=-20] {$1$};
              
                \path[-]  (0) edge (1)
                          (0) edge (2)
                          (1) edge (3)
                          (1) edge (4)
                          (2) edge (5)
                          (2) edge (6)
                          (3) edge (7)
                          (3) edge (8)
                          (4) edge (9);
            \end{graph}
        }
    }\\
    \subfloat[\emph{Vettore heap} con \emph{radice} in 1]
    {
        \resizebox*{0.48\textwidth}{!}{
            \begin{graph}
                \node[rectangle, draw, label={$A[1]$}, minimum width=10mm, minimum height=10mm]
                    (0) {\texttt{16}};
                \node[rectangle, draw, label={$A[2]$}, minimum width=10mm, minimum height=10mm]
                    (1) [right of=0, xshift=-28.5] {\texttt{14}};
                \node[rectangle, draw, label={$A[3]$}, minimum width=10mm, minimum height=10mm]
                    (2) [right of=1, xshift=-28.5] {\texttt{10}};
                \node[rectangle, draw, label={$A[4]$}, minimum width=10mm, minimum height=10mm]
                    (3) [right of=2, xshift=-28.5] {\texttt{8}};
                \node[rectangle, draw, label={$A[5]$}, minimum width=10mm, minimum height=10mm]
                    (4) [right of=3, xshift=-28.5] {\texttt{7}};
                \node[rectangle, draw, label={$A[6]$}, minimum width=10mm, minimum height=10mm]
                    (5) [right of=4, xshift=-28.5] {\texttt{9}};
                \node[rectangle, draw, label={$A[7]$}, minimum width=10mm, minimum height=10mm]
                    (6) [right of=5, xshift=-28.5] {\texttt{3}};
                \node[rectangle, draw, label={$A[8]$}, minimum width=10mm, minimum height=10mm]
                    (7) [right of=6, xshift=-28.5] {\texttt{2}};
                \node[rectangle, draw, label={$A[9]$}, minimum width=10mm, minimum height=10mm]
                    (8) [right of=7, xshift=-28.5] {\texttt{4}};
                \node[rectangle, draw, label={$A[10]$}, minimum width=10mm, minimum height=10mm]
                    (9) [right of=8,xshift=-28.5] {\texttt{1}};
            \end{graph}
        }
    }
    \hfill
    \subfloat[\emph{Vettore heap} con \emph{radice} in 0]
    {
        \resizebox*{0.48\textwidth}{!}{
            \begin{graph}
                \node[rectangle, draw, label={$A[0]$}, minimum width=10mm, minimum height=10mm]
                    (0) {\texttt{16}};
                \node[rectangle, draw, label={$A[1]$}, minimum width=10mm, minimum height=10mm]
                    (1) [right of=0, xshift=-28.5] {\texttt{14}};
                \node[rectangle, draw, label={$A[2]$}, minimum width=10mm, minimum height=10mm]
                    (2) [right of=1, xshift=-28.5] {\texttt{10}};
                \node[rectangle, draw, label={$A[3]$}, minimum width=10mm, minimum height=10mm]
                    (3) [right of=2, xshift=-28.5] {\texttt{8}};
                \node[rectangle, draw, label={$A[4]$}, minimum width=10mm, minimum height=10mm]
                    (4) [right of=3, xshift=-28.5] {\texttt{7}};
                \node[rectangle, draw, label={$A[5]$}, minimum width=10mm, minimum height=10mm]
                    (5) [right of=4, xshift=-28.5] {\texttt{9}};
                \node[rectangle, draw, label={$A[6]$}, minimum width=10mm, minimum height=10mm]
                    (6) [right of=5, xshift=-28.5] {\texttt{3}};
                \node[rectangle, draw, label={$A[7]$}, minimum width=10mm, minimum height=10mm]
                    (7) [right of=6, xshift=-28.5] {\texttt{2}};
                \node[rectangle, draw, label={$A[8]$}, minimum width=10mm, minimum height=10mm]
                    (8) [right of=7, xshift=-28.5] {\texttt{4}};
                \node[rectangle, draw, label={$A[9]$}, minimum width=10mm, minimum height=10mm]
                    (9) [right of=8,xshift=-28.5] {\texttt{1}};
            \end{graph}
        }
    }
    \caption{Memorizzazione \emph{alberi heap}}
\end{figure}

\noindent
Dalle definizioni di \emph{alberi min-heap} e \emph{max-heap} possiamo dedurre
delle proprietà sui relativi \emph{vettori}:
\begin{itemize}
    \item \emph{Vettori min-heap}: $A[i]\leq A[l(i)]$ e $A[i]\leq A[r(i)]$;
    \item \emph{Vettori max-heap}: $A[i]\geq A[l(i)]$ e $A[i]\geq A[r(i)]$;
\end{itemize}

\subsection{Algoritmo HeapSort}
Vediamo quindi l'algoritmo \emph{HeapSort} per l'ordinamento in senso crescente
di un vettore.

L'algoritmo ordina un vettore \q{in-place}, costruendo prima su di esso un
\emph{albero max-heap} e poi spostando progressivamente in fondo gli elemento massimi.
Ad ogni spostamento vengono ripristinate le proprietà degli \emph{alberi max-heap}.

Le funzioni utilizzate sono due:
\begin{itemize}
    \item \texttt{heapBuild}: costruisce un \emph{albero max-heap} a partire da
    un vettore non ordinato;
    \item \texttt{maxHeapRestore}: ripristina le proprietà degli \emph{alberi
    max-heap};
\end{itemize}
\begin{note}
    Tutte le operazioni vengono effettuate \q{in-place}, cioè agiscono sul vettore
    stesso senza usare \emph{strutture ausiliarie}. Quindi, l'\emph{albero max-heap}
    non viene realmente creato, ma grazie alle sue proprietà di memorizzazione,
    il vettore di input viene semplicemente interpretato come fosse un \emph{albero
    max-heap}.
\end{note}
Per questo motivo, la funzione \emph{maxHeapRestore} riceve in input un vettore $A$
e un indice $i$ e si occupa di garantire che al termine dell'esecuzione,
l'\emph{albero binario} con radice $i$ sia un \emph{albero max-heap}.

\begin{eg}[Esempio di esecuzione della maxHeapRestore]
    Consideriamo il seguente vettore:
    \[(3,\,14,\,10,\,8,\,7,\,9,\,5,\,2,\,4,\,1)\]
    e ipotizziamo di invocare \texttt{maxHeapRestore} su di esso usando come
    radice la posizione $1$.

    \begin{figure}[h!]
        \centering
        \subfloat[Situazione iniziale]
        {
            \resizebox*{0.48\textwidth}{!}{
                \begin{graph}
                    \node[main, fill=leaf, line width=1.2pt] (0) {$3$};
                    \node[main] (1) [below left of=0, xshift=-20, yshift=-20] {$14$};
                    \node[main] (2) [below right of=0, xshift=20, yshift=-20] {$10$};
                    \node[main] (3) [below left of=1, xshift=0, yshift=-20] {$8$};
                    \node[main] (4) [below right of=1, xshift=0, yshift=-20] {$7$};
                    \node[main] (5) [below left of=2, xshift=0, yshift=-20] {$9$};
                    \node[main] (6) [below right of=2, xshift=0, yshift=-20] {$5$};
                    \node[main] (7) [below left of=3, xshift=20, yshift=-20] {$2$};
                    \node[main] (8) [below right of=3, xshift=-20, yshift=-20] {$4$};
                    \node[main] (9) [below left of=4, xshift=20, yshift=-20] {$1$};
                  
                    \path[-]  (0) edge (1)
                              (0) edge (2)
                              (1) edge (3)
                              (1) edge (4)
                              (2) edge (5)
                              (2) edge (6)
                              (3) edge (7)
                              (3) edge (8)
                              (4) edge (9);
                \end{graph}
            }
        }
        \hfill
        \subfloat[Il 3 viene scambiato con il 14]
        {
            \resizebox*{0.48\textwidth}{!}{
                \begin{graph}
                    \node[main] (0) {$14$};
                    \node[main, fill=leaf, line width=1.2pt] (1) [below left of=0, xshift=-20, yshift=-20] {$3$};
                    \node[main] (2) [below right of=0, xshift=20, yshift=-20] {$10$};
                    \node[main] (3) [below left of=1, xshift=0, yshift=-20] {$8$};
                    \node[main] (4) [below right of=1, xshift=0, yshift=-20] {$7$};
                    \node[main] (5) [below left of=2, xshift=0, yshift=-20] {$9$};
                    \node[main] (6) [below right of=2, xshift=0, yshift=-20] {$5$};
                    \node[main] (7) [below left of=3, xshift=20, yshift=-20] {$2$};
                    \node[main] (8) [below right of=3, xshift=-20, yshift=-20] {$4$};
                    \node[main] (9) [below left of=4, xshift=20, yshift=-20] {$1$};
                  
                    \path[-]  (0) edge (1)
                              (0) edge (2)
                              (1) edge (3)
                              (1) edge (4)
                              (2) edge (5)
                              (2) edge (6)
                              (3) edge (7)
                              (3) edge (8)
                              (4) edge (9);

                    \path[->, dashed]   (0) edge[bend left=30] (1)
                                        (1) edge[bend left=30] (0);
                \end{graph}
            }
        }\\
        \subfloat[Il 3 viene scambiato con l'8]
        {
            \resizebox*{0.48\textwidth}{!}{
                \begin{graph}
                    \node[main] (0) {$14$};
                    \node[main] (1) [below left of=0, xshift=-20, yshift=-20] {$8$};
                    \node[main] (2) [below right of=0, xshift=20, yshift=-20] {$10$};
                    \node[main, fill=leaf, line width=1.2pt] (3) [below left of=1, xshift=0, yshift=-20] {$3$};
                    \node[main] (4) [below right of=1, xshift=0, yshift=-20] {$7$};
                    \node[main] (5) [below left of=2, xshift=0, yshift=-20] {$9$};
                    \node[main] (6) [below right of=2, xshift=0, yshift=-20] {$5$};
                    \node[main] (7) [below left of=3, xshift=20, yshift=-20] {$2$};
                    \node[main] (8) [below right of=3, xshift=-20, yshift=-20] {$4$};
                    \node[main] (9) [below left of=4, xshift=20, yshift=-20] {$1$};
                  
                    \path[-]  (0) edge (1)
                              (0) edge (2)
                              (1) edge (3)
                              (1) edge (4)
                              (2) edge (5)
                              (2) edge (6)
                              (3) edge (7)
                              (3) edge (8)
                              (4) edge (9);

                    \path[->, dashed]   (1) edge[bend left=30] (3)
                                        (3) edge[bend left=30] (1);
                \end{graph}
            }
        }
        \hfill
        \subfloat[Il 3 viene scambiato con il 4]
        {
            \resizebox*{0.48\textwidth}{!}{
                \begin{graph}
                    \node[main] (0) {$14$};
                    \node[main] (1) [below left of=0, xshift=-20, yshift=-20] {$8$};
                    \node[main] (2) [below right of=0, xshift=20, yshift=-20] {$10$};
                    \node[main] (3) [below left of=1, xshift=0, yshift=-20] {$4$};
                    \node[main] (4) [below right of=1, xshift=0, yshift=-20] {$7$};
                    \node[main] (5) [below left of=2, xshift=0, yshift=-20] {$9$};
                    \node[main] (6) [below right of=2, xshift=0, yshift=-20] {$5$};
                    \node[main] (7) [below left of=3, xshift=20, yshift=-20] {$2$};
                    \node[main, fill=leaf, line width=1.2pt] (8) [below right of=3, xshift=-20, yshift=-20] {$3$};
                    \node[main] (9) [below left of=4, xshift=20, yshift=-20] {$1$};
                  
                    \path[-]  (0) edge (1)
                              (0) edge (2)
                              (1) edge (3)
                              (1) edge (4)
                              (2) edge (5)
                              (2) edge (6)
                              (3) edge (7)
                              (3) edge (8)
                              (4) edge (9);
                  
                    \path[->, dashed]   (3) edge[bend left=30] (8)
                                        (8) edge[bend left=30] (3);
                \end{graph}
            }
        }
    \end{figure}\noindent
    Al termine dell'esecuzione abbiamo ottenuto un albero max-heap corretto.
\end{eg}

\newpage
\paragraph{Implementazione}
\begin{minicode}{Implementazione maxHeapRestore}
    \ind maxHeapRestore(\bc{ITEM}[] A, \bc{int} i, \bc{int} dim)\\
        \bc{int} max = i\hfill\com{Sceglie la \emph{radice}}
        \indf if (l(i) $\leq$ dim A[l(i)] > A[max]) then\\
            max = l(i)\\
        \indf if (r(i) $\leq$ dim A[r(i)] > A[max]) then\\
            max = r(i)\\
        \indf if (i $\neq$ max) then\hfill\com{Se $i == max$ l'\emph{albero} è apposto}
            swap(A, i, max)\hfill\com{Scambia la \emph{radice} e il maggiore tra i suoi \emph{figli}}
            maxHeapRestore(A, max, dim)\hfill\com{Controlla il \emph{sottoalbero} con \emph{radice} $max$}
\end{minicode}
\paragraph{Complessità}
Ad ogni chiamata vengono eseguiti $O(1)$ confronti e se il \emph{nodo} $i$ non è
massimo, si invoca ricorsivamente \texttt{maxHeapRestore} su uno dei \emph{figli}.
L'esecuzione nel caso peggiore termina al raggiungimento di una \emph{foglia},
quindi il costo è limitato dall'\emph{altezza} dell'\emph{albero}, ovvero
$T(n)=O(\log n)$.

\paragraph{Dimostrazione di correttezza}
\begin{proof}[Dimostrazione]
    Dobbiamo dimostrare che al termine dell'esecuzione l'\emph{albero} con
    \emph{radice} in $A[i]$ rispetta le proprietà degli \emph{alberi max-heap}.
    Procediamo per induzione sull'\emph{altezza} $h$ dell'\emph{albero}.

    \paragraph{Caso base} $h=0$. L'\emph{albero} è composto da un solo
    \emph{nodo} e quindi rispetta per forza le proprietà.
    \paragraph{Passo induttivo} Ipotizziamo che l'algoritmo funzioni correttamente
    su tutti gli \emph{alberi} di \emph{altezza} minore di $h$. A questo punto si
    configurano tre casi:
    \begin{itemize}
        \item \emph{Caso 1}: $A[i]\geq A[l(i)]$ e $A[i]\geq A[r(i)]$, ovvero
        il \emph{nodo} $A[i]$ è più grande dei propri \emph{figli} e quindi
        l'\emph{albero radicato} in $A[i]$ è un \emph{albero max-heap} e l'algoritmo
        termina;
        \item \emph{Caso 2}: $A[i]<A[l(i)]$ e $A[r(i)]<A[l(i)]$, ovvero il \emph{figlio
        sinistro} è più grande sia del \emph{padre} che del \emph{fratello}. Quindi,
        vengono scambiati di posizione il \emph{figlio sinistro} e il \emph{padre}.
        A questo punto valgono $A[i]\geq A[l(i)]$ e $A[i]\geq A[r(i)]$, ma il
        \emph{sottoalbero} con \emph{radice} in $A[l(i)]$ potrebbe non rispettare
        più le proprietà per gli \emph{alberi max-heap}. Di conseguenza, l'algoritmo
        continua applicando ricorsivamente \texttt{maxHeapRestore} sull'\emph{albero}
        con \emph{radice} in $A[l(i)]$, ma siccome quell'\emph{albero} ha \emph{altezza}
        minore di $h$, per ipotesi induttiva, l'algoritmo riesce correttamente a
        garantire il rispetto di tutte le proprietà;
        \item \emph{Caso 3}: $A[i]<A[r(i)]$ e $A[l(i)]<A[r(i)]$, ovvero il \emph{figlio
        destro} è più grande sia del \emph{padre} che del \emph{fratello}. Quindi,
        vengono scambiati di posizione il \emph{figlio destro} e il \emph{padre}.
        A questo punto valgono $A[i]\geq A[l(i)]$ e $A[i]\geq A[r(i)]$, ma il
        \emph{sottoalbero} con \emph{radice} in $A[r(i)]$ potrebbe non rispettare
        più le proprietà per gli \emph{alberi max-heap}. Di conseguenza, l'algoritmo
        continua applicando ricorsivamente \texttt{maxHeapRestore} sull'\emph{albero}
        con \emph{radice} in $A[r(i)]$, ma siccome quell'\emph{albero} ha \emph{altezza}
        minore di $h$, per ipotesi induttiva, l'algoritmo riesce correttamente a
        garantire il rispetto di tutte le proprietà;
    \end{itemize}
\end{proof}\noindent
Consideriamo ora la funzione \texttt{heapBuild}. La funzione riceve in input un
vettore da ordinare e, per le proprietà di memorizzazione degli \emph{alberi heap},
sappiamo che tutti i \emph{nodi} con indici compresi tra $\lfloor n/2\rfloor+1$
e $n$ sono \emph{foglie}, ovvero \emph{alberi heap} contenenti un solo elemento.

La funzione \texttt{heapBuild} quindi, non fa altro che applicare \texttt{maxHeapRestore}
a tutti i \emph{nodi}, partendo dal primo che non è una \emph{foglia}, cioè da
$A[\lfloor n/2\rfloor]$, e risalendo fino alla \emph{radice}.

\paragraph{Implementazione}
\begin{minicode}{Implementazione heapBuild}
    \ind heapBuild(\bc{ITEM}[] A, \bc{int} n)\\
        \indf for (i = $\lfloor$n/2$\rfloor$ downto 1) do\\
            maxHeapRestore(A, i, n)
\end{minicode}
\begin{figure}[h!]
    \centering
    \begin{graph}
        \node[main, label={$A[1]$}] (0) {$14$};
        \node[main, label={$A[2]$}] (1) [below left of=0, xshift=-20, yshift=-20] {$45$};
        \node[main, label={$A[3]$}] (2) [below right of=0, xshift=20, yshift=-20] {$28$};
        \node[main, label={$A[4]$}] (3) [below left of=1, xshift=0, yshift=-20] {$34$};
        \node[main, label={$A[5]$}] (4) [below right of=1, xshift=0, yshift=-20] {$15$};
        \node[main, fill=leaf, label={$A[6]$}] (5) [below left of=2, xshift=0, yshift=-20] {$20$};
        \node[main, fill=leaf, label={$A[7]$}] (6) [below right of=2, xshift=0, yshift=-20] {$22$};
        \node[main, fill=leaf, label=below:{$A[8]$}] (7) [below left of=3, xshift=20, yshift=-20] {$30$};
        \node[main, fill=leaf, label=below:{$A[9]$}] (8) [below right of=3, xshift=-20, yshift=-20] {$21$};
        \node[main, fill=leaf, label=below:{$A[10]$}] (9) [below left of=4, xshift=20, yshift=-20] {$25$};
        \node[main, fill=leaf, label=below:{$A[11]$}] (10) [below right of=4, xshift=-20, yshift=-20] {$16$};
      
        \path[-]  (0) edge (1)
                  (0) edge (2)
                  (1) edge (3)
                  (1) edge (4)
                  (2) edge (5)
                  (2) edge (6)
                  (3) edge (7)
                  (3) edge (8)
                  (4) edge (9)
                  (4) edge (10);
    \end{graph}
    \caption{\texttt{maxHeapRestore} viene applicata solo ai \emph{nodi} interni}
\end{figure}
\paragraph{Dimostrazione di correttezza}
\begin{proof}[Dimostrazione]
    Dimostriamo la seguente \emph{invariante di ciclo}:
    
    \smallskip\noindent {\em All'inizio di ogni iterazione del ciclo \texttt{for},
    i nodi $[i+1\dots n]$ sono radici di alberi heap.}
    \paragraph{Inizializzazione}
    All'inizio $i=\lfloor n/2\rfloor$. Supponiamo che $\lfloor n/2\rfloor+1$ non
    sia una \emph{foglia} e che quindi abbia almeno il \emph{figlio sinistro}.
    Se così fosse, il \emph{figlio} dovrebbe trovarsi alla posizione $2(\lfloor
    n/2\rfloor+1)=2\lfloor n/2\rfloor+2$, ma ciò sarebbe assurdo perché le posizioni
    $n+1$ e $n+2$ eccedono la dimensione massima che $n$. La stessa dimostrazione
    vale anche per tutti gli indici successivi.
    \paragraph{Conservazione}
    È possibile applicare \texttt{maxHeapRestore} a ogni \emph{nodo} $i\in[\lfloor
    n/2\rfloor+1\dots n]$ perché entrambi i \emph{nodi} alle posizioni $2i<2i+1\leq
    n$ sono \emph{radici} di \emph{alberi heap}. Al termine di ogni iterazioni,
    i \emph{nodi} $[i\dots n]$ sono \emph{radici} di \emph{alberi heap}.
    \paragraph{Conclusione} Al termine, $i=0$ e quindi il \emph{nodo} $1$ è
    \emph{radice} di un \emph{albero heap}.
\end{proof}
\paragraph{Complessità}
Sicuramente possiamo dire che \texttt{heapBuild} è un $O(n\log n)$ in quanto il costo
di \texttt{maxHeapRestore} è $O(\log n)$ e viene invocata $\lfloor n/2\rfloor=O(n)$
volte. Ma è veramente questo il costo?

\bigskip\noindent
In realtà, le operazioni \texttt{maxHeapRestore} vengono eseguite un
numero decrescente di volte in un \emph{albero} di \emph{altezza} crescente. E in
particolare, vale la seguente tabella:

\begin{table}[h!]
    \centering
    \renewcommand{\arraystretch}{1.2}
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Altezza} & \textbf{\# esecuzioni}\\
        \hline
        0 & $\lfloor n/2^1\rfloor$\\
        \hline
        1 & $\lfloor n/2^2\rfloor$\\
        \hline
        2 & $\lfloor n/2^3\rfloor$\\
        \hline
        \dots & \dots\\
        \hline
        $h$ & $\lfloor n/2^{h+1}\rfloor$\\
        \hline
    \end{tabular}
\end{table}\noindent
Se questo è vero, possiamo scrivere la \emph{funzione di ricorrenza} come:
\[T(n)\begin{array}[t]{cll}
    \leq & \sum_{h=1}^{\lfloor n/2\rfloor}\frac{n}{2^{h+1}}h\\
    = & n\sum_{h=1}^{\lfloor n/2\rfloor}\left(\frac{1}{2}\right)^{h+1}h\\
    = & \frac{n}{2}\sum_{h=1}^{\lfloor n/2\rfloor}\left(\frac{1}{2}\right)^{h}h\\
    \leq & \frac{n}{2}\sum_{h=1}^{+\infty}\left(\frac{1}{2}\right)^{h}h & \quad\emph{Estensione ad infinito della somamtoria}\\
    = & \frac{n}{2}\frac{\frac{1}{2}}{\left(1-\frac{1}{2}\right)^2} & \quad\hyperlink{ser:5}{\emph{Serie geometrica infinita decrescente}}\\
    = & \frac{n}{2}\frac{\frac{1}{2}}{\left(\frac{1}{2}\right)^2}\\
    = & \frac{n}{2}2\\
    = & n = O(n)
\end{array}\]

\paragraph{Implementazione}
\begin{minicode}{Implementazione dell'algoritmo HeapSort}
    \ind heapsort(\bc{ITEM}[] A, \bc{int} n)\\
        heapBuild(A, n)\\
        \indf for (i = n downto 2) do\\
            swap(A, 1, i)\hfill\com{L'elemento massimo viene spostato in fondo}
            maxHeapRestore(A, 1, n - 1)\hfill\com{Ripristina le proprietà}
\end{minicode}\noindent
In pratica, l'\emph{HeapSort} inizia costruendo un \emph{albero max-heap} sul
vettore da ordinare. Ad ogni ciclo il primo elemento sarà sicuramente il
massimo e quindi viene scambiato di posto con l'elemento in posizione $i$.
Dopo ogni scambio viene invocata \texttt{maxHeapRestore} per ripristinare le
proprietà degli \emph{alberi max-heap}. Il tutto viene ripetuto fino a quando
$i$ non diventa 1.

\paragraph{Complessità}
La funzione \texttt{heapBuild} costa $\Theta(n)$, mentre le \texttt{maxHeapRestore}
ha un costo $\Theta(\log i)$ per $i$ che varia da $n$ a 2. La \emph{funzione di
ricorrenza} è la seguente:
\[T(n)=\sum_{i=n}^2\log i+\Theta(n)=\Theta(n\log n)\]

\paragraph{Dimostrazione di correttezza}
\begin{proof}[Dimostrazione]
    Dimostriamo la seguente \emph{invariante di ciclo}:
    
    \smallskip\noindent{\em All'inizio di ogni passo $i$ il sottovettore
    $A[i+1\dots n]$ è ordinato e ogni elemento in $A[1\dots i]$ è minore o
    al più uguale a ogni elemento in $A[i+1\dots n]$. Inoltre, l'elemento $A[1]$
    è la radice di un albero heap di dimensione $i$.}
    \paragraph{Inizializzazione}
    Dopo la \texttt{heapBuild} il primo elemento è la \emph{radice} di un
    \emph{albero max-heap} e quindi è maggiore dei propri \emph{figli} e, per la
    proprietà transitiva, anche dei \emph{figli} dei \emph{figli} fino alle
    \emph{foglie}. Alla prima iterazione quindi, $A[1]$ è il massimo e viene
    scambiato di posto con $A[i]=A[n]$. A quel punto, $A[n]$ è l'elemento
    massimo e il sottovettore $A[1\dots n-1]$ viene riorganizzato secondo le
    regole della \texttt{maxHeapRestore} portandone il massimo in $A[1]$.
    \paragraph{Conservazione}
    Per ogni $i\in[2\dots n]$, il sottovettore $A[i+1\dots n]$ è ordinato
    in senso crescente e in posizione $A[1]$ si trova l'elemento massimo del
    sottovettore $A[1\dots i]$. Al termine dell'iterazione, $A[i\dots n]$ è
    ordinato e $A[1]$ è il massimo in $A[1\dots i-1]$.
    \paragraph{Conclusione}
    Al termine, $i=1$ e quindi il sottovettore $A[2\dots n]$ è ordinato. Poiché
    vale sicuramente $A[1]\leq A[2]$, possiamo dire che tutto il vettore $A[1\dots
    n]$ è ordinato in senso crescente.
\end{proof}

\subsection{Implementazione di code a priorità}
Prima di vedere l'implementazione di una \emph{coda a priorità}, vediamo la
definizione di un \texttt{\bc{PRIORITYITEM}} e l'implementazione della funzione
\texttt{swap}.
\begin{minicode}{PRIORITYITEM}
    \bc{int} priority\hfill\com{Valore di priorità}
    \bc{ITEM} value\hfill\com{Valore}
    \bc{int} pos\hfill\com{Posizione nel vettore}
\end{minicode}
\begin{minicode}{Implementazione funzione swap}
    \ind swap(\bc{PRIORITYITEM} H, \bc{int} i, \bc{int} j)\\
        \bc{PRIORITYITEM} temp = H[i]\\
        H[i] = H[j]\\
        H[j] = temp\\
        H[i].pos = i\\
        H[j].pos = j
\end{minicode}\noindent
Di seguito quindi, vediamo l'implementazione di una \emph{min-priority queue}
come vettore di coppie $\langle valore,\,\emph{priorità}\rangle$. Ovviamente,
tutto ciò che vedremo vale simmetrico per le \emph{max-priority queue}.
\begin{minicode}{{Min-priority queue}}
    \bc{int} capacity\hfill\com{Dimensione massima della \emph{coda}}
    \bc{int} dim\hfill\com{Numero di elementi attualmente presenti nella \emph{coda}}
    \bc{PRIORITYQUEUE}[] H\hfill\com{\emph{Vettore heap}}
\end{minicode}
\newpage
\begin{codecont}
    \ind\bc{PRIORITYQUEUE} PriorityQueue(\bc{int} n)\\
        \bc{PRIORITYQUEUE} t = new \bc{PRIORITYQUEUE}\\
        t.capacity = n\\
        t.dim = 0\\
        t.H = new \bc{PRIORITYITEM}[1\dots n]\\
        return t\\

    \ind\bc{PRIORITYITEM} insert(\bc{ITEM} x, \bc{int} p)\\
        precondition: dim < capacity\\
        dim = dim + 1\\
        H[dim] = new \bc{PRIORITYITEM}\hfill\com{Aggiunge l'elemento in fondo}
        H[dim].value = x\\
        H[dim].priority = p\\
        H[dim].pos = dim\\
        \bc{int} i = dim\\
        \indf while (i > 1 and H[i].priority < H[p(i)].priority) do\\
            \indff swap(H, i, p(i))\hfill\com{Sposta il nuovo elemento nella posizione giusta}
            \indff i = p(i)\\
        \indf return H[i]\\

    \ind minHeapRestore(\bc{PRIORITYITEM}[] A, \bc{int} i, \bc{int} n)\\
        \bc{int} min = i\\
        if (l(i) $\leq$ dim and A[l(i)].priority < A[min].priority) then\\
            \indf min = l(i)\\
        \ind if (r(i) $\leq$ dim and A[r(i)].priority < A[min].priority) then\\
            \indf min = r(i)\\
        \ind if (i $\neq$ min) then\\
            \indf swap(A, i, min)\\
            \indf minHeapRestore(A, min, dim)\\

    \ind\bc{ITEM} deleteMin()\\
        precondition: dim > 0\\
        swap(H, 1, dim)\hfill\com{Scambia il primo e l'ultimo elemento}
        dim = dim - 1\\
        minHeapRestore(H, 1, dim)\hfill\com{Ripristina le proprietà}
        return H[dim + 1].value\hfill\com{Restituisce il valore dell'elemento rimosso}

    \ind\bc{ITEM} min()\\
        precondition: dim > 0\\
        return H[1].value\\
    
    \ind decrease(\bc{PRIORITYITEM} x, \bc{int} p)\\
        precondition: p < x.priority\\
        x.priority = p\\
        \bc{int} i = x.pos\\
        while (i > 1 and H[i].priority < H[p(i)].priority) do\\
            \indf swap(H, i, p(i))\hfill\com{Sposta l'elemento modificato nella posizione giusta}
            \indf i = p(i)
\end{codecont}
\paragraph{Complessità}
Tutte le operazioni che modificano gli \emph{heap} ne ripristinano anche le
proprietà. In particolare, questo viene fatto nel \emph{cammino radice-foglia}
dalla \texttt{deleteMin} e in quello \emph{nodo-radice} dalla \texttt{insert}
e dalla \texttt{decrease}. Poiché l'\emph{altezza} è $\lfloor\log n\rfloor$, il
costo di tali operazioni è $O(\log n)$.

\bigskip\noindent
La \emph{complessità} di tutte le operazioni è riassunta dalla seguente tabella:
\begin{table}[h!]
    \centering
    \renewcommand{\arraystretch}{1.2}
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Operazione} & \textbf{Costo}\\
        \hline
        \texttt{insert} & $O(\log n)$\\
        \hline
        \texttt{deleteMin} & $O(\log n)$\\
        \hline
        \texttt{min} & $\Theta(1)$\\
        \hline
        \texttt{decrease} & $O(\log n)$\\
        \hline
    \end{tabular}
\end{table}
