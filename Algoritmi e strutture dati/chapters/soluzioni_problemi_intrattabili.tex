\chapter{Soluzioni per problemi intrattabili}
A questo punto è chiaro che per alcuni problemi non è sempre possibile trovare
la soluzione ottima in tempo \emph{polinomiale}. Per arrivare comunque ad una
soluzione siamo dunque costretti a rinunciare a qualcosa, e questo significa
perdere una o più delle seguenti caratteristiche:
\begin{itemize}
    \item \emph{Generalità}: potremmo accettare di definire un algoritmo che
    sia efficiente solo per alcuni casi dell'input;
    \item \emph{Ottimalità}: potremmo accettare di ottenere soluzioni \q{vicine}
    a quella ottima;
    \item \emph{Formalità}: potremmo accettare di definire un algoritmo che
    sperimentalmente dimostri fornire risultati buoni;
    \item \emph{Efficienza}: potremmo accettare di perdere in efficienza, ma
    ottenere la soluzione globalmente ottima;
\end{itemize}
Come vedremo in questo capitolo, ciascuno di questi punti è associato ad una
particolare categoria di algoritmi.

\section{Algoritmi pseudo-polinomiali}
Partiamo con un problema ormai noto: \hyperref[prob:33]{SUBSET-SUM}.
Abbiamo già risolto questo problema utilizzando il \emph{backtracking}, ora
però proviamo risolverlo di nuovo con una soluzione basata su
\emph{programmazione dinamica} per poi confrontare le \emph{complessità} delle
due soluzioni ottenute.

\subsection{Problema del subset sum}
\paragraph{Soluzione con programmazione dinamica}
Come al solito, definiamo una \emph{tabella delle soluzioni}
$DP[0\dots n][0\dots k]$ tale per cui $DP[i][r]$ è \texttt{true} se esiste un
sottoinsieme dei primi $i$ valori di $A$ la cui somma sia esattamente $r$,
\texttt{false} altrimenti:
\[DP[i][r]=\begin{cases}
    \texttt{true} & r=0\\
    \texttt{false} & r>0\wedge i=0\\
    DP[i-1][r] & r>0\wedge i>0\wedge A[i]>r\\
    DP[i-1][r] or DP[i-1][r-A[i]] & r>0\wedge i>0\wedge A[i]\leq r
\end{cases}\]
Le prime due clausole di questa definizione fanno sì che i valori della prima
colonna della tabella siano tutti \texttt{true} e quelli della prima riga, ad
eccezione del primo, siano tutti \texttt{false}. È giusto che sia così perché
se $r=0$ è sufficiente considerare l'insieme vuoto, mentre se $i=0$ e $r>0$
non è possibile definire alcun sottoinsieme diverso da quello vuoto.

\begin{minicode}{Soluzione basata su programmazione dinamica}
\ind\bc{boolean} subsetSum(\bc{int}[] A, \bc{int} n, \bc{int} k)\\
    \bc{boolean}[][] DP = new \bc{boolean}[0\dots n][0\dots k] = \{false\}\\
    \indf for (i = 0 to n) do\hfill\com{Prima colonna}
        DP[i][0] = true\hfill\com{Obiettivo raggiunto}
    \indf for (r = 1 to k) do\hfill\com{Prima riga}
        DP[0][r] = false\hfill\com{Valori terminati}
    \indf for (i = 1 to n) do\\
        \indff for (r = 1 to A[i] - 1) do\hfill\com{$r<A[i]$}
            DP[i][r] = DP[i - 1][r]\\
        \indff for (r = A[i] to k) do\hfill\com{$r\geq A[i]$}
            DP[i][r] = DP[i - 1][r] or DP[i - 1][r - A[i]]\\
    \indf return DP[n][k]
\end{minicode}
\noindent
La \emph{complessità} di questa soluzione è $\Theta(nk)$ perché $DP$ ha quella
dimensione.

\paragraph{Soluzione con backtracking}
\begin{minicode}{Soluzione basata su backtracking}
\ind\bc{boolean} ssRec(\bc{int}[] A, \bc{int} i, \bc{int} r)\\
    \indf if (r == 0) then\hfill\com{Obiettivo raggiunto}
        return true\\
    \indf else if (i == 0) then\hfill\com{Valori terminati}
        return false\\
    \indf else if (A[i] > r) then\\
        return ssRec(A, i - 1, r)\\
    \indf else \\
        return ssRec(A, i - 1, r) or ssRec(A, i - 1, r - A[i])
\end{minicode}

\noindent
Poiché nel caso peggiore vengono eseguite 2 chiamate ricorsive per ogni livello,
la \emph{complessità} è $O(2^n)$.

\paragraph{Soluzione con memoization}
Possiamo scrivere una soluzione basata su \emph{memoization} in cui, per non
dover inizializzare l'intera tabella, memorizziamo le soluzioni in un \emph{dizionario}.

\begin{minicode}{Soluzione basata su backtracking}
    \ind\bc{boolean} ssRec(\bc{int}[] A, \bc{int} i, \bc{int} r, \bc{DICTIONARY} DP)\\
        \indf if (r == 0) then\hfill\com{Obiettivo raggiunto}
            return true\\
        \indf else if (i == 0) then\hfill\com{Valori terminati}
            return false\\
        \indf else\\
            \bc{boolean} res = DP.lookup($\langle$i, r$\rangle$)\\
            \indff if (res == nil) then\hfill\com{La soluzione non è ancora stata calcolata}
                res = ssRec(A, i - 1, r, DP)\hfill\com{Valore non preso}
                \indfff if (A[i] $\leq$ r) then\\
                    res = res or ssRec(A, i - 1, r - A[i], DP)\hfill\com{Valore preso}
                \indfff DP.insert($\langle$i, r$\rangle$, res)\\
            \indff return res
\end{minicode}

\noindent
In questo caso l'algoritmo è limitato superiormente sia da $O(nk)$ che da
$O(2^n)$. Il primo limite dipende dal fatto che, nel caso peggiore, il
\emph{dizionario} viene popolato con tutti gli $nk$ valori come avviene nella
soluzione con \emph{programmazione dinamica} classica.

Se invece il vettore $A$ fosse popolato interamente di $1$, ad ogni livello
della ricorsione si realizzerebbero due chiamate, portando quindi la complessità
a $O(2^n)$. Di conseguenza, la \emph{complessità} della soluzione con
\emph{memoization} è $O(\min(nk, 2^n))$.

\bigskip\noindent
La \emph{complessità} $O(nk)$ è \emph{polinomiale}?

Precedentemente abbiamo già risposto a questa domanda, dicendo che no, non è
una \emph{complessità polinomiale}, bensì \emph{pseudo-polinomiale}. Il motivo è
che $k$ è parte dell'input e non una sua dimensione. In particolare, $k$ viene
rappresentato da $t=\lceil\log k\rceil$ cifre binarie, quindi $O(nk)$ può anche
essere scritto come $O(n2^t)$ che è una \emph{complessità esponenziale}.

\subsection[Problemi fortemente e debolmente NP-completi]
{Problemi fortemente e debolmente $\mathbb{NP}$-completi}
Per continuare la discussione sul tema della \emph{pseudo-polinomialità}
introduciamo i \emph{problemi fortemente e debolmente $\mathbb{NP}$-completi}.

\begin{definition}[Dimensioni del problema]
    Dati un problema decisionale $R$ e un'istanza $I$, chiamiamo $d$ la lunghezza
    della stringa binaria che codifica $I$ e definiamo il valore $\#$ come il
    più grande numero che appare in $I$.
\end{definition}

\noindent
Ad esempio, per i problemi SUBSET-SUM, \hyperref[prob:28]{CLIQUE} e
\hyperref[prob:30]{TSP}, i valori $d$ ed $\#$ sono i seguenti:

\begin{table}[h!]
    \centering
    \renewcommand{\arraystretch}{1.2}
    \begin{tabular}{|c|c|c|c|}
        \hline
        \bc{Problema} & \bm{$I$} & \bm{$\#$} & \bm{$d$}\\
        \hline
        SUBSET-SUM & $\{n, k, A\}$ & $\max\{n, k, \max(A)\}$ & $O(n \log\#)$\\
        \hline
        CLIQUE & $\{n,m,k,G\}$ & $\max\{n,m,k\}$ & $O(n+m+\log\#)$\\
        \hline
        TSP & $\{n,k,d\}$ & $\max\{n,k,\max(d)\}$ & $O(n^2\log\#)$\\
        \hline
    \end{tabular}
\end{table}

\noindent
L'idea dietro il valore $\#$ è che se tutti i valori sono codificati nello
stesso modo (e.g. tutti i valori di $A$ sono interi a 32 bit), il valore maggiore
definisce la dimensione minima della stringa di codifica per ciascun valore di
quell'insieme. Conseguentemente, poiché $d$ descrive la dimensione della stringa
di codifica dell'intero input, il suo valore dipende dalla numerosità dell'input
e dalla dimensione di ciascuna sua componente.

Da qui,  nel problema SUBSET-SUM, $d$ è definito come $O(n\log\#)$ perché
l'input è composto da $n+2$ valori: $n$, $k$ e gli $n$ valori del vettore $A$.
Ciascuno di quegli elementi poi, richiede $\#$ bit per essere rappresentato, e
nel \emph{criterio di costo uniforme} tutto ciò si traduce in una
\emph{complessità} di $O(n\log\#)$.

\begin{definition}[Problema fortemenete $\mathbb{NP}$-completo]
    Sia $R_{pol}$ il problema $R$ ristretto ai dati di input per i quali $\#$
    è limitato superiormente da $T_p(d)$, con $T_p$ funzione polinomiale di $d$.
    $R$ è fortemente $\mathbb{NP}$-completo se e solo se $R_{pol}$ è
    $\mathbb{NP}$-completo.
\end{definition}

\begin{definition}[Problema debolmente $\mathbb{NP}$-completo]
    Se un problema $\mathbb{NP}$-completo non è fortemente $\mathbb{NP}$-completo,
    allora è debolmente $\mathbb{NP}$-completo.
\end{definition}

\paragraph{Dimostrazione che SUBSET-SUM è debolmente $\mathbb{NP}$-completo}
\begin{proof}[Dimostrazione]
    Supponiamo che $A[i]\leq k\quad\forall i\in\{1,\dots,n\}$, perché in ogni
    caso valori più grandi di $k$ non potrebbero essere parte della soluzione.
    Se $k=O(n^c)$, allora il valore $\#$ è definito come $\#=\max\{n, k, a_1,
    \dots, a_n\}=O(n^c)$. Ora, la soluzione basata su \emph{programmazione
    dinamica} ha \emph{complessità} $O(nk)=O(n^{c+1})$ che è \emph{polinomiale},
    e quindi appartenente a $\mathbb{P}$, quindi SUBSET-SUM non è \emph{fortemente
    $\mathbb{NP}$-completo}.
\end{proof}

\begin{definition}[Complessità pseduo-polinomiale]
    Un algoritmo ha complessità pseudo-polinomiale se risolve un certo problema
    $R$, per qualsiasi input $I$, in tempo $T_p(\#,d)$, con $T_p$ funzione
    con tempo polinomiale non costante in $\#$.
\end{definition}
\begin{definition}[Legame tra $\mathbb{NP}$-completezza e pseudo-polinomialità]
    Nessun problema fortemente $\mathbb{NP}$-completo è risolvibile da un
    algoritmo pseudo-polinomiale, a meno che non valga $\mathbb{P}=\mathbb{NP}$.
\end{definition}
\begin{note}
    Gli algoritmi per SUBSET-SUM e \hyperref[prob:34]{KNAPSACK} sono
    \emph{pseudo-polinomiali}.
\end{note}

\paragraph{Dimostrazione che CLIQUE è fortemente $\mathbb{NP}$-completo}
\begin{proof}[Dimostrazione]
    Possiamo supporre $k\leq n$, perché altrimenti la risposta sarebbe
    sicuramente \texttt{false}. Se è così, il valore $\#$ è definito come
    $\#=\max\{n,m,k\}=\max\{n,m\}$. Conseguentemente, $d$ vale $O(n+m+\log\#)=
    O(n+m)$. Ora, siccome $\#$ definito in questo modo è già limitato superiormente
    da $O(n+m)$, il problema ristretto è uguale alla versione completa di CLIQUE
    che è \emph{$\mathbb{NP}$-completo}, quindi CLIQUE è un problema
    \emph{fortemente $\mathbb{NP}$-completo}.
\end{proof}

\noindent
L'idea alla base di questo tipo di dimostrazioni è quella di considerare
un sottoinsieme degli input, calcolare $\#$ e $d$ a partire dall'input
ridotto e, se la versione ridotta del problema ha \emph{complessità
polinomiale}, allora il problema originale è \emph{debolmente
$\mathbb{NP}$-completo} e ammette una soluzione di costo \emph{pseudo-polinomiale}.

\begin{note}
    Ovviamente, qualsiasi problema che è riducibile ad un problema
    \emph{debolmente $\mathbb{NP}$-completo} è esso stesso \emph{debolmente
    $\mathbb{NP}$-completo}. Ad esempio, \hyperref[prob:32]{PARTITION} può
    essere ridotto a SUBSET-SUM scegliendo come $k$ la meta della somma di tutti
    i valori presenti, e siccome SUBSET-SUM è \emph{debolmente
    $\mathbb{NP}$-completo}, lo è anche PARTITION.
\end{note}

\section{Algoritmi di approssimazione}
Diversamente da quanto fatto finora, per la trattazione degli \emph{algoritmi
di approssimazione} consideriamo \emph{problemi di ottimizzazione} invece di
\emph{problemi decisionali}.

\begin{definition}[Algoritmo di approssimazione]
    Se è possibile dimostrare che esiste un limite superiore o inferiore al
    rapporto tra la soluzione trovata e la soluzione ottima, allora l'algoritmo
    usato per ricavare la soluzione non ottima è detto essere un algoritmo di
    approssimazione.
\end{definition}
\begin{definition}[Algoritmo di \bm{$\alpha(n)$}-approssimazione]
    Dato un problema di ottimizzazione sul quale è definita una funzione di costo
    non negativa $c$, un algoritmo si dice essere di $\alpha(n)$-approssimazione
    se fornisce una soluzione ammissibile $x$, il cui costo $c(x)$ non si discosti
    dal costo $c(x^*)$ della soluzione ottima $x^*$ per più di un fattore
    $\alpha(n)$, per qualunque input di dimensione $n$.
\end{definition}

\noindent
I \emph{problemi di ottimizzazione} si dividono in due sotto-categorie:
\emph{problemi di massimizzazione} e \emph{problemi di minimizzazione}.
A seconda della sotto-categoria di appartenenza del problema, un \emph{algoritmo
di approssimazione} è tale se soddisfa una delle seguenti relazioni:
\[\begin{array}{rccclll}
    \alpha(n)c(x^*) & \leq & c(x) & \leq & c(x^*) & \quad\alpha(n)<1 & \quad\emph{Problema di massimizzazione}\\
    c(x^*) & \leq & c(x) & \leq & \alpha(n)c(x^*) & \quad\alpha(n)>1 & \quad\emph{Problema di minimizzazione}
\end{array}\]

\begin{note}
    Il fattore $\alpha(n)$ può dipendere da $n$ o essere una costante, in ogni
    caso, dimostrare che il valore scelto sia rispettato dall'algoritmo è ciò che
    rende quell'algoritmo un \emph{algoritmo di approssimazione}.
\end{note}

\subsection{Problema del bin packing approssimato}
\begin{problem}[Problema del bin packing]
    Dato un vettore $A$ contenente $n$ interi positivi, rappresentanti ciascuno il
    volume di un oggetto, e un intero positivo $k$, rappresentante la capacità di
    una scatola e tale per cui $A[i]\leq k\quad\forall i\in\{1,\dots,n\}$,
    trovare una partizione dell'insieme di indici $\{1,\dots,n\}$ che minimizzi
    il numero di sottoinsiemi disgiunti tali che $\sum_{i\in S}A[i]\leq k$
    per ogni insieme $S$ della partizione.
\end{problem}
\begin{note}
    In pratica, si vuole capire come distribuire $n$ oggetti in delle scatole
    in modo che il numero di scatole totali sia minimo.
\end{note}

\noindent
Questo problema può essere approcciato in una quantità di modi, i primi che
potrebbero venire in mente sono il \emph{best fit} e il \emph{first fit}.
Il primo cerca di piazzare ogni oggetto nella scatola in cui la capacità residua
dopo l'inserimento è minima. Il secondo invece, prende un oggetto alla volta e
lo inserisce nella prima scatola con capacità sufficiente per contenerlo.

\bigskip\noindent
Consideriamo l'algoritmo \emph{first fit} e proviamo a vedere se è un
\emph{algoritmo di approssimazione}.

\begin{proof}[Dimostrazione]
    Sia $N$ il numero di scatole usate dall'algoritmo \emph{first fit}. Il numero
    minimo di scatole utilizzabili $N^*$ è limitato inferiormente da:
    \[N^*\geq\frac{\sum_{i=1}^nA[i]}{k}\]
    Poiché non possono esserci due scatole riempite per meno della metà\footnotemark,
    $N$ è limitato superiormente da:
    \[N\leq\frac{\sum_{i=1}^nA[i]}{k/2}\]
    Se è così, vale quanto segue:
    \[N\leq\frac{\sum_{i=1}^nA[i]}{k/2}=2\frac{\sum_{i=1}^nA[i]}{k}\leq 2N^*\]
    Da qui risulta che il fattore $\alpha(n)$ vale $2$.
\end{proof}
\begin{note}
    È anche possibile dimostrare limiti più stretti, ma quello che ci importa è
    aver dimostrato con successo che \emph{first fit} è un \emph{algoritmo di
    approssimazione} per il problema del \emph{bin packing}.
\end{note}

\footnotetext{Non possono esserci due scatole riempite per meno della metà perché
il contenuto di una di quelle due sarebbe stato messo nell'altra}

\subsection{Problema del commesso viaggiatore modificato}
\begin{problem}[Commesso viaggiatore con disuguaglianze triangolari ($\bc{\Delta}$-TSP)]
    Date $n$ città e una matrice $d$ delle distanze tra esse tale per cui:
    \[d[i][j]\leq d[i][k]+d[k][j]\quad\forall i,j,k: 1\leq i,j,k\leq n\]
    trovare un percorso che parta da una città, visiti tutte le altre
    esattamente una volta e ritorni alla città di partenza, in modo che la
    distanza complessiva percorsa sia minima.
\end{problem}
\begin{note}
    Le distanze tra le città devono rispettare la cosiddetta \q{disuguaglianza
    triangolare}.
\end{note}
\begin{figure}[h!]
    \centering
    \subfloat[Con disuguaglianza triangolare]{\begin{graph}
        \tikzset{node distance=35mm}

        \node[main] (b) {$b$};
        \node[main] (a) [below left of=b] {$a$};
        \node[main] (c) [below right of=b] {$c$};

        \node[] (d) [below of=b] {$d[a][c]\leq d[a][b]+d[b][c]$};

        \path[-]    (a) edge node[above left] {$3$} (b)
                    (a) edge node[above] {$5$} (c)
                    (b) edge node[above right] {$3$} (c);
    \end{graph}}
    \hspace{1.5cm}
    \subfloat[Senza disuguaglianza triangolare]{\begin{graph}
        \tikzset{node distance=35mm}

        \node[main] (b) {$b$};
        \node[main] (a) [below left of=b] {$a$};
        \node[main] (c) [below right of=b] {$c$};

        \node[] (d) [below of=b] {$d[a][c]\geq d[a][b]+d[b][c]$};

        \path[-]    (a) edge node[above left] {$2$} (b)
                    (a) edge node[above] {$5$} (c)
                    (b) edge node[above right] {$2$} (c);
    \end{graph}}
    \caption{\emph{Grafo} con e senza disuguaglianza triangolare}
\end{figure}

\paragraph{$\mathbb{NP}$-completezza di \bm{$\Delta$}-TSP}
Possiamo dimostrare che $\Delta$-TSP è \emph{riducibile polinomialmente} a
\hyperref[prob:35]{HAMILTONIAN-CIRCUIT} e poiché questo è
\emph{$\mathbb{NP}$-completo}, lo è anche $\Delta$-TSP.

\begin{proof}[Dimostrazione]
    Sia $G=(V,E)$ un \emph{grafo non orientato} avente un \emph{nodo} per ognuna
    delle $n$ città, e definiamo a partire da esso una matrice delle distanze
    tale per cui:
    \[d[i][j]=\begin{cases}
        1 & (i,j)\in E\\
        2 & (i,j)\notin E
    \end{cases}\]
    Poiché valgono le disuguaglianze triangolari, per ogni coppia di \emph{nodi}
    $i$, $j$ vale $d[i][j]\leq 2\leq d[i][k]+d[k[j]]$. A questo punto, $G$ ha
    un circuito hamiltoniano se e solo se esiste un \emph{cammino} in $d$ di
    lunghezza $n$ e passante per ogni \emph{nodo}.
\end{proof}
\begin{note}
    La matrice $d$ definisce il costo dell'arco tra ogni coppia di \emph{nodi},
    quindi ci permette di trattare $G$ come se fosse un \emph{grafo completo}.
\end{note}

\noindent
In generale possiamo sempre interpretare TSP o $\Delta$-TSP come il problema di
ricercare il circuito hamiltoniano di peso minimo su un \emph{grafo pesato
completo}.

\paragraph{Algoritmo in generale}
Per definire un \emph{algoritmo di approssimazione} per $\Delta$-TSP
partiamo proprio da questa interpretazione. In particolare, consideriamo un
circuito hamiltoniano e ne cancelliamo un \emph{arco} in modo da ottenere un
\emph{albero di copertura}.

\begin{definition}[Lemma sul costo dell'albero di copertura di peso minimo]
    Qualunque circuito hamiltoniano $\pi$ ha un costo $c(\pi)$ che è superiore
    al costo $mst$ di un albero di copertura di peso minimo dello stesso grafo.
    Ovvero, per ogni circuito hamiltoniano $\pi$ vale $mst<c(\pi)$.
\end{definition}

\begin{figure}[ht!]
\centering
\scalebox{1}{\begin{graph}
    \tikzset{
        cell/.style={rectangle, draw, minimum size=10mm, font=\large},
        empty/.style={inner sep=0},
        pos/.style args={#1:#2 from #3}{
          at=(#3.#1), anchor=#1+180, shift=(#1:#2)
        }
    }

    \def\labels{1 2 3 4 5}
    \def\numbers{%
        0 3 4 2 7
        3 0 4 6 3
        4 4 0 5 8
        2 6 5 0 6
        7 3 8 6 0
    }
    \readarray\labels\la[1,5]
    \readarray\numbers\num[5,5]

    \foreach \x in {1,...,5}
        \foreach \y in {1,...,5}
        {
            \ifthenelse{\x = 1\and\y=1}{
                \node[cell] (\x\y) at (\x-1,-\y+1) [label=above:{$\la[1,1]$},
                label=left:{$\la[1,1]$}] {};
            }{
                \ifthenelse{\x=1}{
                    \node[cell] (\x\y) at (\x-1,-\y+1) [label=left:{$\la[1,\y]$}]
                    {$\num[\x,\y]$};
                }{
                    \ifthenelse{\y = 1}{
                        \node[cell] (\x\y) at (\x-1,-\y+1)[label=above:{$\la[1,\x]$}]
                        {$\num[\x,\y]$};
                    }{
                        \ifthenelse{\num[\x,\y]=0}{
                            \node[cell] (\x\y) at (\x-1,-\y+1) {};
                        }{
                            \node[cell] (\x\y) at (\x-1,-\y+1) {$\num[\x,\y]$};
                        }
                    }
                }    
            }
        }

    \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
    \node[main]     (1) [pos=90:20mm from 0] {$1$};
    \node[main]     (2) [pos=18:20mm from 0] {$2$};
    \node[main]     (3) [pos=-54:20mm from 0] {$3$};
    \node[main]     (4) [pos=-126:20mm from 0] {$4$};
    \node[main]     (5) [pos=-198:20mm from 0] {$5$};

    \path[-,dashed] (1) edge node[fill=white] {$3$} (2)
                    (1) edge node[fill=white] {$7$} (5)
                    (2) edge node[fill=white] {$6$} (4)
                    (3) edge node[fill=white] {$8$} (5)
                    (3) edge node[fill=white] {$5$} (4);

    \path[-]
                    (1) edge[line width=1.3pt] node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge[line width=1.3pt] node[fill=white] {$3$} (5)
                    (2) edge[line width=1.3pt] node[fill=white] {$4$} (3)
                    (5) edge[line width=1.3pt] node[fill=white] {$6$} (4);
\end{graph}}
\caption{Interpretazione di $\Delta$-TSP come circuito hamiltoniano pesato}
\end{figure}

\begin{proof}[Dimostrazione]
    Supponiamo per assurdo che esista un circuito hamiltoniano $\pi$ di costo
    $c(\pi)\leq mst$. Se eliminiamo un \emph{arco} di $\pi$ otteniamo un altro
    \emph{albero di copertura} $mst'$ di costo $mst'<c(\pi)\leq mst$. Questo
    genera una contraddizione in quanto avevo supposto che $mst$ fosse il costo
    dell'\emph{albero di copertura di peso minimo}.
\end{proof}

\noindent
Quindi, se individuiamo un \emph{albero di copertura} di peso $mst$ e ne
percorriamo ogni \emph{arco} due volte, prima in un senso e poi nell'altro,
otteniamo un circuito di costo $2\cdot mst$ nel quale ogni \emph{nodo} viene
visitato una o due volte. Ovviamente questo non è un circuito hamiltoniano, ma
se saltiamo i \emph{nodi} già visitati e passiamo direttamente a quelli non
visitati, poiché valgono le disuguaglianze triangolare, il costo del circuito
$\pi$ così ottenuto è inferiore o uguale a $2\cdot mst$.

\bigskip\noindent
Di conseguenza, vale:
\[c(\pi)\leq 2\cdot mst\leq 2\cdot c(\pi^*)\]
dove $c(\pi^*)$ è il costo del circuito hamiltoniano di peso minimo e $2$ corrisponde
anche al valore del fattore $\alpha(n)$.

\begin{eg}[Esempio d'esecuzione]
    Consideriamo il seguente grafo completo sul quale abbiamo individuato
    un albero di copertura di peso minimo:
    
    \begin{figure}[h!]
        \centering
        \scalebox{0.95}{\begin{graph}
            \node[main] (1) {$1$};
            \node[main] (2) [below right of=1, shift={(15mm, 3mm)}] {$2$};
            \node[main] (3) [below of=2, shift={(3mm, 0mm)}] {$3$};
            \node[main] (4) [left of=3, shift={(-20mm, -1mm)}] {$4$};
            \node[main] (5) [right of=3, shift={(20mm, 7mm)}] {$5$};
            \node[main] (6) [below right of=5, shift={(6mm, 6mm)}] {$6$};
            \node[main] (7) [above of=6, shift={(5mm, 10mm)}] {$7$};

            \path[-]    (1) edge[line width=1.3pt] (2)
                        (2) edge[line width=1.3pt] (3)
                        (3) edge[line width=1.3pt] (4)
                        (3) edge[line width=1.3pt] (5)
                        (5) edge[line width=1.3pt] (6)
                        (5) edge[line width=1.3pt] (7);

            \draw[, dashed]
                        (1) edge[bend left=5] (7)
                        (7) edge[bend left=5] (6)
                        (6) edge[bend left=10] (4)
                        (6) edge[bend left=10] (3)
                        (4) edge[bend left=5] (1)
                        (3) edge[bend left=5] (1)
                        (3) edge[bend left=5] (7)
                        (4) edge[bend left=5] (2)
                        (4) edge[bend left=8] (5)
                        (4) edge (7)
                        (2) edge (7)
                        (2) edge (5)
                        (2) edge[bend left=25] (6)
                        (1) edge[bend left=25] (6)
                        (1) edge[bend right=15] (5);
        \end{graph}}
    \end{figure}

    \noindent
    Se adesso percorressimo ogni arco dell'albero di copertura individuato in
    entrambi i sensi, otterremmo il seguente circuito:

    \begin{figure}[h!]
        \centering
        \scalebox{1}{\begin{graph}
            \node[main] (1) {$1$};
            \node[main] (2) [below right of=1, shift={(15mm, 3mm)}] {$2$};
            \node[main] (3) [below of=2, shift={(3mm, 0mm)}] {$3$};
            \node[main] (4) [left of=3, shift={(-20mm, -1mm)}] {$4$};
            \node[main] (5) [right of=3, shift={(20mm, 7mm)}] {$5$};
            \node[main] (6) [below right of=5, shift={(6mm, 6mm)}] {$6$};
            \node[main] (7) [above of=6, shift={(5mm, 10mm)}] {$7$};

            \path[->, bend left=15]
                        (1) edge (2)
                        (2) edge (3)
                        (3) edge (4)
                        (3) edge (5)
                        (5) edge (6)
                        (5) edge (7);

            \path[<-, bend right=15]
                        (1) edge (2)
                        (2) edge (3)
                        (3) edge (4)
                        (3) edge (5)
                        (5) edge (6)
                        (5) edge (7);
        \end{graph}}
    \end{figure}

    \noindent
    A questo punto, sfruttando le disuguaglianze triangolari, otteniamo che,
    per esempio, per passare dal nodo $7$ al nodo $6$ conviene usare l'arco
    $(7,6)$ invece che tornare indietro sul nodo $5$ già visitato:

    \begin{figure}[h!]
        \centering
        \scalebox{1}{\begin{graph}
            \node[main] (1) {$1$};
            \node[main] (2) [below right of=1, shift={(15mm, 3mm)}] {$2$};
            \node[main] (3) [below of=2, shift={(3mm, 0mm)}] {$3$};
            \node[main] (4) [left of=3, shift={(-20mm, -1mm)}] {$4$};
            \node[main] (5) [right of=3, shift={(20mm, 7mm)}] {$5$};
            \node[main] (6) [below right of=5, shift={(6mm, 6mm)}] {$6$};
            \node[main] (7) [above of=6, shift={(5mm, 10mm)}] {$7$};

            \path[->, bend left=15]
                        (5) edge (7)
                        (7) edge (6);

            \path[->, bend left=15, dashed]
                        (7) edge (5)
                        (5) edge (6);
        \end{graph}}
    \end{figure}

    \noindent
    Applicando la stessa nozione a tutti gli altri nodi, otteniamo finalmente
    un circuito hamiltoniano:

    \begin{figure}[h!]
        \centering
        \scalebox{1}{\begin{graph}
            \node[main] (1) {$1$};
            \node[main] (2) [below right of=1, shift={(15mm, 3mm)}] {$2$};
            \node[main] (3) [below of=2, shift={(3mm, 0mm)}] {$3$};
            \node[main] (4) [left of=3, shift={(-20mm, -1mm)}] {$4$};
            \node[main] (5) [right of=3, shift={(20mm, 7mm)}] {$5$};
            \node[main] (6) [below right of=5, shift={(6mm, 6mm)}] {$6$};
            \node[main] (7) [above of=6, shift={(5mm, 10mm)}] {$7$};

            \path[->, bend left=15]
                        (1) edge (5)
                        (5) edge (7)
                        (7) edge (6)
                        (6) edge (3)
                        (3) edge (4)
                        (4) edge (2)
                        (2) edge (1);
        \end{graph}}
    \end{figure}    
\end{eg}

\paragraph{Complessità}
L'algoritmo proposto sfrutta l'\emph{Algoritmo di Kruskal} per la ricerca
dell'\emph{albero di copertura di peso minimo} e una \emph{visita in
profondità}. L'\emph{Algoritmo di Kruskal} costa $O(n^2\log n)$, la \emph{vista}
$O(n)$, quindi la \emph{complessità} totale è $T(n)=O(n^2\log n)$.

\begin{definition}[Teorema di non approssimabilità di TSP]
    Non esiste alcun algoritmo di $\alpha(n)$-approssimazione per TSP tale
    che $c(x')\leq s\cdot c(x^*)$, con $s\in\mathbb{N}$, a meno che non valga
    $\mathbb{P}=\mathbb{NP}$.
\end{definition}

\section{Algoritmi euristici}
Come abbiamo già visto in precedenza, gli \emph{algoritmi euristici} permettono
di ottenere delle soluzioni ammissibili per problemi complessi, che però possono
non essere né soluzioni ottime né soluzioni approssimate. Spesso le soluzioni
euristiche vengono definite a partire da intuizioni per \emph{algoritmi greedy}
oppure sfruttano di tecniche tipiche della \emph{ricerca locale}. 

\bigskip\noindent
Continuiamo la trattazione continuando a parlare di TSP e vediamo due soluzioni
euristiche di tipo \emph{greedy} e una di \emph{ricerca locale}.

\subsection{Prima soluzione greedy - Arco di costo minimo}
Un'idea potrebbe essere quella di ordinare gli \emph{archi} per pesi non
decrescenti e di aggiungere un \emph{arco} alla volta alla soluzione, prendendo
di volta in volta quello di peso minore. Ovviamente la frase precedente non è
formalmente corretta, in quanto non possiamo prendere un \emph{arco} se uno dei
suoi estremi è già raggiunto da due \emph{archi} della soluzione. Inoltre,
dobbiamo anche evitare che si formino circuiti, e per questo sfruttiamo i
\emph{merge-find set}. Infine, se $n$ è il numero di \emph{nodi}, l'$n$-esimo
\emph{arco} deve essere per forza l'\emph{arco} che collega gli ultimi due
\emph{nodi} estremi della catena.
\begin{note}
    Un circuito hamiltoniano privo di un \emph{arco} è semplicemente una
    \q{catena} di \emph{nodi}.
\end{note}

\begin{eg}[Esempio d'esecuzione]
Consideriamo lo stesso grafo completo dell'esempio precedente:

\begin{figure}[h!]
    \centering
    \scalebox{0.85}{\begin{graph}
        \tikzset{
            cell/.style={rectangle, draw, minimum size=10mm, font=\large},
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }
    
        \def\labels{1 2 3 4 5}
        \def\numbers{%
            0 3 4 2 7
            3 0 4 6 3
            4 4 0 5 8
            2 6 5 0 6
            7 3 8 6 0
        }
        \readarray\labels\la[1,5]
        \readarray\numbers\num[5,5]
    
        \foreach \x in {1,...,5}
            \foreach \y in {1,...,5}
            {
                \ifthenelse{\x = 1\and\y=1}{
                    \node[cell] (\x\y) at (\x-1,-\y+1) [label=above:{$\la[1,1]$},
                    label=left:{$\la[1,1]$}] {};
                }{
                    \ifthenelse{\x=1}{
                        \node[cell] (\x\y) at (\x-1,-\y+1) [label=left:{$\la[1,\y]$}]
                        {$\num[\x,\y]$};
                    }{
                        \ifthenelse{\y = 1}{
                            \node[cell] (\x\y) at (\x-1,-\y+1)[label=above:{$\la[1,\x]$}]
                            {$\num[\x,\y]$};
                        }{
                            \ifthenelse{\num[\x,\y]=0}{
                                \node[cell] (\x\y) at (\x-1,-\y+1) {};
                            }{
                                \node[cell] (\x\y) at (\x-1,-\y+1) {$\num[\x,\y]$};
                            }
                        }
                    }    
                }
            }
    
        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main]     (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main]     (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};
    
        \path[-] (1) edge node[fill=white] {$3$} (2)
                        (1) edge node[fill=white] {$7$} (5)
                        (2) edge node[fill=white] {$6$} (4)
                        (3) edge node[fill=white] {$8$} (5)
                        (3) edge node[fill=white] {$5$} (4)
                        (1) edge node[fill=white] {$4$} (3)
                        (1) edge node[fill=white] {$2$} (4)
                        (2) edge node[fill=white] {$3$} (5)
                        (2) edge node[fill=white] {$4$} (3)
                        (5) edge node[fill=white] {$6$} (4);
    \end{graph}}
\end{figure}

\noindent
Passo dopo passo, l'algoritmo opera le seguenti scelte:

\begin{figure}[h!]
    \centering
    \subfloat[Prima scelta]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main]     (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main]     (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};

        \path[-]    (1) edge node[fill=white] {$3$} (2)
                    (1) edge node[fill=white] {$7$} (5)
                    (2) edge node[fill=white] {$6$} (4)
                    (3) edge node[fill=white] {$8$} (5)
                    (3) edge node[fill=white] {$5$} (4)
                    (1) edge node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge node[fill=white] {$3$} (5)
                    (2) edge node[fill=white] {$4$} (3)
                    (5) edge node[fill=white] {$6$} (4);
    \end{graph}}}
    \hspace{5mm}
    \subfloat[Seconda scelta]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main]     (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main]     (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};

        \path[-]    (1) edge node[fill=white] {$3$} (2)
                    (1) edge node[fill=white] {$7$} (5)
                    (2) edge node[fill=white] {$6$} (4)
                    (3) edge node[fill=white] {$8$} (5)
                    (3) edge node[fill=white] {$5$} (4)
                    (1) edge node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge[line width=1.3pt] node[fill=white] {$3$} (5)
                    (2) edge node[fill=white] {$4$} (3)
                    (5) edge node[fill=white] {$6$} (4);
    \end{graph}}}
    \hspace{5mm}
    \subfloat[Terza scelta]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main]     (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main]     (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};

        \path[-]    (1) edge[line width=1.3pt] node[fill=white] {$3$} (2)
                    (1) edge node[fill=white] {$7$} (5)
                    (2) edge node[fill=white] {$6$} (4)
                    (3) edge node[fill=white] {$8$} (5)
                    (3) edge node[fill=white] {$5$} (4)
                    (1) edge node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge[line width=1.3pt] node[fill=white] {$3$} (5)
                    (2) edge node[fill=white] {$4$} (3)
                    (5) edge node[fill=white] {$6$} (4);
    \end{graph}}}
\end{figure}
\newpage
\begin{figure}[ht!]
    \ContinuedFloat
    \centering
    \subfloat[Quarta scelta]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main]     (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main]     (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};

        \path[-]    (1) edge[line width=1.3pt] node[fill=white] {$3$} (2)
                    (1) edge node[fill=white] {$7$} (5)
                    (2) edge node[fill=white] {$6$} (4)
                    (3) edge node[fill=white] {$8$} (5)
                    (3) edge[line width=1.3pt] node[fill=white] {$5$} (4)
                    (1) edge[dashed] node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge[line width=1.3pt] node[fill=white] {$3$} (5)
                    (2) edge[dashed] node[fill=white] {$4$} (3)
                    (5) edge node[fill=white] {$6$} (4);
    \end{graph}}}
    \hspace{15mm}
    \subfloat[Ultima scelta]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main]     (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main]     (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};

        \path[-]    (1) edge[line width=1.3pt] node[fill=white] {$3$} (2)
                    (1) edge[dashed] node[fill=white] {$7$} (5)
                    (2) edge[dashed] node[fill=white] {$6$} (4)
                    (3) edge[line width=1.3pt] node[fill=white] {$8$} (5)
                    (3) edge[line width=1.3pt] node[fill=white] {$5$} (4)
                    (1) edge[dashed] node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge[line width=1.3pt] node[fill=white] {$3$} (5)
                    (2) edge[dashed] node[fill=white] {$4$} (3)
                    (5) edge[dashed] node[fill=white] {$6$} (4);
    \end{graph}}}
\end{figure}

\noindent
Dopo la terza scelta vengono estratti i due archi di peso $4$, ma poiché i nodi
$1$ e $2$ sono già collegati a due archi nell'insieme della soluzione, i due
archi da $4$ non possono essere selezionati. Alla fine invece, l'ultimo arco
scelto è proprio quello più costoso per cui tutti gli i precedenti archi sono
stati estratti e ignorati.

\bigskip\noindent Il costo del circuito individuato è $21$ e noi già sappiamo
che quello di costo minimo ha un costo di $19$, quindi, come ci aspettavamo,
la soluzione trovata non è ottimale.
\end{eg}
\begin{note}
    Sarebbe possibile interrompere l'estrazione degli \emph{archi} dopo
    l'$(n-1)$-esimo, ma questo tipo di accorgimenti non cambiano le dinamiche
    generali dell'algoritmo, e soprattutto non ne modificano la \emph{complessità}.
\end{note}

\begin{minicode}{Implementazione prima soluzione greedy}
\ind\bc{SET} greedyTsp(\bc{GRAPH} G)\\
    \bc{SET} result = Set()\hfill\com{Insieme della soluzione}
    \bc{MFSET} M = Mfset(G.size())\\
    \bc{int}[] edges = new \bc{int}[1\dots G.size()] = \{0\}\hfill\com{\emph{Archi} collegati a ogni \emph{nodo}}
    \bc{int}[] A = \{ Ordina gli archi per peso non decrescente \}\\
    \indf foreach ($\langle$u, v$\rangle$ $\in$ A) do\\
        \indff if (edges[u] < 2 and edges[v] < 2 and M.find(u) $\neq$ M.find(v)) then\\
            result.insert($\langle$u, v$\rangle$)\\
            edges[u] = edges[u] + 1\\
            edges[v] = edges[v] + 1\\
            M.merge(u, v)\\
    \indf\com{Cerca le due estremità della catena per determinare l'\emph{arco} mancante}
    \indf\bc{int} u = 1\\
    \indf while (edges[u] $\neq$ 1) do\\
        u = u + 1\\
    \indf\bc{int} v = u + 1\\
    \indf while (edges[v] $\neq$ 1) do\\
            v = v + 1\\
    \indf result.insert($\langle$u, v$\rangle$)\\
    \indf return result
\end{minicode}

\paragraph{Complessità}
L'ordinamento degli \emph{archi} costa $O(m\log m)$, ma poiché stiamo lavorano
con \emph{grafi completi} $m=O(n^2)$, quindi la \emph{complessità} diventa
$O(n^2\log n)$.

\subsection{Seconda soluzione greedy - Vicino più vicino}
Un'altra possibilità è quella di partire da un \emph{nodo} e di muoversi di
volta in volta verso il \emph{nodo adiacente} più vicino, cioè quello collegato
con l'\emph{arco} di peso minore. Una visitati tutti i \emph{nodi}, si seleziona
l'\emph{arco} di peso minimo verso il \emph{nodo} di partenza.

\begin{eg}[Esempio d'esecuzione]
Continuiamo a considerare sempre lo stesso grafo completo:

\begin{figure}[h!]
    \centering
    \scalebox{0.85}{\begin{graph}
        \tikzset{
            cell/.style={rectangle, draw, minimum size=10mm, font=\large},
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }
    
        \def\labels{1 2 3 4 5}
        \def\numbers{%
            0 3 4 2 7
            3 0 4 6 3
            4 4 0 5 8
            2 6 5 0 6
            7 3 8 6 0
        }
        \readarray\labels\la[1,5]
        \readarray\numbers\num[5,5]
    
        \foreach \x in {1,...,5}
            \foreach \y in {1,...,5}
            {
                \ifthenelse{\x = 1\and\y=1}{
                    \node[cell] (\x\y) at (\x-1,-\y+1) [label=above:{$\la[1,1]$},
                    label=left:{$\la[1,1]$}] {};
                }{
                    \ifthenelse{\x=1}{
                        \node[cell] (\x\y) at (\x-1,-\y+1) [label=left:{$\la[1,\y]$}]
                        {$\num[\x,\y]$};
                    }{
                        \ifthenelse{\y = 1}{
                            \node[cell] (\x\y) at (\x-1,-\y+1)[label=above:{$\la[1,\x]$}]
                            {$\num[\x,\y]$};
                        }{
                            \ifthenelse{\num[\x,\y]=0}{
                                \node[cell] (\x\y) at (\x-1,-\y+1) {};
                            }{
                                \node[cell] (\x\y) at (\x-1,-\y+1) {$\num[\x,\y]$};
                            }
                        }
                    }    
                }
            }
    
        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main]     (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main]     (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};
    
        \path[-] (1) edge node[fill=white] {$3$} (2)
                        (1) edge node[fill=white] {$7$} (5)
                        (2) edge node[fill=white] {$6$} (4)
                        (3) edge node[fill=white] {$8$} (5)
                        (3) edge node[fill=white] {$5$} (4)
                        (1) edge node[fill=white] {$4$} (3)
                        (1) edge node[fill=white] {$2$} (4)
                        (2) edge node[fill=white] {$3$} (5)
                        (2) edge node[fill=white] {$4$} (3)
                        (5) edge node[fill=white] {$6$} (4);
    \end{graph}}
\end{figure}

\noindent
Passo dopo passo, l'algoritmo opera le seguenti scelte:

\begin{figure}[h!]
    \centering
    \subfloat[Prima scelta]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main, line width=1.3pt] (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main]     (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};
    
        \path[-]    (1) edge node[fill=white] {$3$} (2)
                    (1) edge node[fill=white] {$7$} (5)
                    (2) edge node[fill=white] {$6$} (4)
                    (3) edge node[fill=white] {$8$} (5)
                    (3) edge node[fill=white] {$5$} (4)
                    (1) edge node[fill=white] {$4$} (3)
                    (1) edge node[fill=white] {$2$} (4)
                    (2) edge node[fill=white] {$3$} (5)
                    (2) edge node[fill=white] {$4$} (3)
                    (5) edge node[fill=white] {$6$} (4);
    \end{graph}}}
    \hspace{5mm}
    \subfloat[Seconda scelta]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main, line width=1.3pt] (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main, line width=1.3pt] (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};
    
        \path[-]    (1) edge[dashed] node[fill=white] {$3$} (2)
                    (1) edge[dashed] node[fill=white] {$7$} (5)
                    (2) edge node[fill=white] {$6$} (4)
                    (3) edge node[fill=white] {$8$} (5)
                    (3) edge node[fill=white] {$5$} (4)
                    (1) edge[dashed] node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge node[fill=white] {$3$} (5)
                    (2) edge node[fill=white] {$4$} (3)
                    (5) edge node[fill=white] {$6$} (4);
    \end{graph}}}
    \hspace{5mm}
    \subfloat[Terza scelta]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main, line width=1.3pt] (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main, line width=1.3pt] (3) [pos=-54:20mm from 0] {$3$};
        \node[main, line width=1.3pt] (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};
    
        \path[-]    (1) edge[dashed] node[fill=white] {$3$} (2)
                    (1) edge[dashed] node[fill=white] {$7$} (5)
                    (2) edge[dashed] node[fill=white] {$6$} (4)
                    (3) edge node[fill=white] {$8$} (5)
                    (3) edge[line width=1.3pt] node[fill=white] {$5$} (4)
                    (1) edge[dashed] node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge node[fill=white] {$3$} (5)
                    (2) edge node[fill=white] {$4$} (3)
                    (5) edge[dashed] node[fill=white] {$6$} (4);
    \end{graph}}}\\
    \subfloat[Quarta scelta]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main, line width=1.3pt] (1) [pos=90:20mm from 0] {$1$};
        \node[main, line width=1.3pt] (2) [pos=18:20mm from 0] {$2$};
        \node[main, line width=1.3pt] (3) [pos=-54:20mm from 0] {$3$};
        \node[main, line width=1.3pt] (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};
    
        \path[-]    (1) edge[dashed] node[fill=white] {$3$} (2)
                    (1) edge[dashed] node[fill=white] {$7$} (5)
                    (2) edge[dashed] node[fill=white] {$6$} (4)
                    (3) edge[dashed] node[fill=white] {$8$} (5)
                    (3) edge[line width=1.3pt] node[fill=white] {$5$} (4)
                    (1) edge[dashed] node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge node[fill=white] {$3$} (5)
                    (2) edge[line width=1.3pt] node[fill=white] {$4$} (3)
                    (5) edge[dashed] node[fill=white] {$6$} (4);
    \end{graph}}}
    \hspace{5mm}
    \subfloat[Quinta scelta]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main, line width=1.3pt] (1) [pos=90:20mm from 0] {$1$};
        \node[main, line width=1.3pt] (2) [pos=18:20mm from 0] {$2$};
        \node[main, line width=1.3pt] (3) [pos=-54:20mm from 0] {$3$};
        \node[main, line width=1.3pt] (4) [pos=-126:20mm from 0] {$4$};
        \node[main, line width=1.3pt] (5) [pos=-198:20mm from 0] {$5$};
    
        \path[-]    (1) edge[dashed] node[fill=white] {$3$} (2)
                    (1) edge[dashed] node[fill=white] {$7$} (5)
                    (2) edge[dashed] node[fill=white] {$6$} (4)
                    (3) edge[dashed] node[fill=white] {$8$} (5)
                    (3) edge[line width=1.3pt] node[fill=white] {$5$} (4)
                    (1) edge[dashed] node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge[line width=1.3pt] node[fill=white] {$3$} (5)
                    (2) edge[line width=1.3pt] node[fill=white] {$4$} (3)
                    (5) edge[dashed] node[fill=white] {$6$} (4);
    \end{graph}}}
    \hspace{5mm}
    \subfloat[Ultima scelta]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main, line width=1.3pt] (1) [pos=90:20mm from 0] {$1$};
        \node[main, line width=1.3pt] (2) [pos=18:20mm from 0] {$2$};
        \node[main, line width=1.3pt] (3) [pos=-54:20mm from 0] {$3$};
        \node[main, line width=1.3pt] (4) [pos=-126:20mm from 0] {$4$};
        \node[main, line width=1.3pt] (5) [pos=-198:20mm from 0] {$5$};
    
        \path[-]    (1) edge[dashed] node[fill=white] {$3$} (2)
                    (1) edge[dashed] node[fill=white] {$7$} (5)
                    (2) edge[dashed] node[fill=white] {$6$} (4)
                    (3) edge[line width=1.3pt] node[fill=white] {$8$} (5)
                    (3) edge[line width=1.3pt] node[fill=white] {$5$} (4)
                    (1) edge[dashed] node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge[line width=1.3pt] node[fill=white] {$3$} (5)
                    (2) edge[line width=1.3pt] node[fill=white] {$4$} (3)
                    (5) edge[dashed] node[fill=white] {$6$} (4);
    \end{graph}}}
\end{figure}

\noindent
Il circuito ottenuto costa $21$ come il precedente.
\end{eg}

\paragraph{Complessità}
Per quanto riguarda la \emph{complessità}, questa soluzione si comporta meglio
della precedente, in quanto scegliere l'\emph{arco} uscente di peso minimo
per $n-1$ \emph{nodi} di un \emph{grafo completo} costa $O(n^2)$.

\subsection{Soluzione con ricerca locale}
L'idea è quella che se $\pi$ è un qualche circuito hamiltoniano del \emph{grafo},
possiamo modificare $\pi$ e ottenere un circuito di costo minore. In particolare,
possiamo scegliere due \emph{archi} non consecutivi in $\pi$ e sostituirli con
altri due \emph{archi} non già inclusi in $\pi$. Quindi, il nuovo circuito $\pi'$
ottenuto è un intorno di $\pi$ nel quale abbiamo cambiato due \emph{archi}.

Il processo di sostituzione termina quando non è più possibile ridurre il
costo del circuito, ovvero quando si arriva ad un minimo locale, che come
abbiamo già visto, potrebbe non coincidere con il minimo globale.

\begin{figure}[h!]
    \centering
    \scalebox{0.85}{\begin{graph}
        \node[main] (a1) {$a_1$};
        \node[main] (a2) [right of=a1, xshift=10mm] {$a_2$};
        \node[main] (b1) [below of=a1] {$b_1$};
        \node[main] (b2) [right of=b1, xshift=10mm] {$b_2$};

        \draw[-, dashed] (a1.180) edge[bend right=90] (b1.180);
        \draw[-, dashed] (a2.0) edge[bend left=90] (b2.0);

        \path[-]    (a1) edge (a2)
                    (b1) edge (b2);
        
        \node[] (f) [below right of=a2, shift={(20mm,3mm)}] {$\Longrightarrow$};

        \node[main] (a11) [above right of=f, shift={(20mm,-3mm)}] {$a_1$};
        \node[main] (a21) [right of=a11, xshift=10mm] {$a_2$};
        \node[main] (b11) [below of=a11] {$b_1$};
        \node[main] (b21) [right of=b11, xshift=10mm] {$b_2$};

        \draw[-, dashed] (a11.180) edge[bend right=90] (b11.180);
        \draw[-, dashed] (a21.0) edge[bend left=90] (b21.0);

        \path[-]    (a11) edge (b21)
                    (b11) edge (a21);
    \end{graph}}
    \caption{Esempio di sostituzione}
\end{figure}

\noindent
Scelti i due \emph{archi} $(a_1,a_2)$ e $(b_1,b_2)$ da sostituire, l'unico modo
per richiudere il circuito senza riutilizzare quegli stessi \emph{archi}, è
quello di sostituirli con gli \emph{archi} $(a_1,b_1)$ e $(a_2,b_2)$.

\begin{eg}[Esempio d'esecuzione]
Riprendiamo il solito grafo completo:

\begin{figure}[h!]
    \centering
    \scalebox{0.85}{\begin{graph}
        \tikzset{
            cell/.style={rectangle, draw, minimum size=10mm, font=\large},
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }
    
        \def\labels{1 2 3 4 5}
        \def\numbers{%
            0 3 4 2 7
            3 0 4 6 3
            4 4 0 5 8
            2 6 5 0 6
            7 3 8 6 0
        }
        \readarray\labels\la[1,5]
        \readarray\numbers\num[5,5]
    
        \foreach \x in {1,...,5}
            \foreach \y in {1,...,5}
            {
                \ifthenelse{\x = 1\and\y=1}{
                    \node[cell] (\x\y) at (\x-1,-\y+1) [label=above:{$\la[1,1]$},
                    label=left:{$\la[1,1]$}] {};
                }{
                    \ifthenelse{\x=1}{
                        \node[cell] (\x\y) at (\x-1,-\y+1) [label=left:{$\la[1,\y]$}]
                        {$\num[\x,\y]$};
                    }{
                        \ifthenelse{\y = 1}{
                            \node[cell] (\x\y) at (\x-1,-\y+1)[label=above:{$\la[1,\x]$}]
                            {$\num[\x,\y]$};
                        }{
                            \ifthenelse{\num[\x,\y]=0}{
                                \node[cell] (\x\y) at (\x-1,-\y+1) {};
                            }{
                                \node[cell] (\x\y) at (\x-1,-\y+1) {$\num[\x,\y]$};
                            }
                        }
                    }    
                }
            }
    
        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main]     (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main]     (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};
    
        \path[-] (1) edge node[fill=white] {$3$} (2)
                        (1) edge node[fill=white] {$7$} (5)
                        (2) edge node[fill=white] {$6$} (4)
                        (3) edge node[fill=white] {$8$} (5)
                        (3) edge node[fill=white] {$5$} (4)
                        (1) edge node[fill=white] {$4$} (3)
                        (1) edge node[fill=white] {$2$} (4)
                        (2) edge node[fill=white] {$3$} (5)
                        (2) edge node[fill=white] {$4$} (3)
                        (5) edge node[fill=white] {$6$} (4);
    \end{graph}}
\end{figure}

\noindent
Partendo da un circuito hamiltoniano qualsiasi, l'algoritmo si comporta come
segue:

\begin{figure}[h!]
    \centering
    \subfloat[Circuito iniziale]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main]     (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main]     (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};
    
        \path[-]    (1) edge[line width=1.3pt] node[fill=white] {$3$} (2)
                    (1) edge[line width=1.3pt] node[fill=white] {$7$} (5)
                    (2) edge node[fill=white] {$6$} (4)
                    (3) edge node[fill=white] {$8$} (5)
                    (3) edge[line width=1.3pt] node[fill=white] {$5$} (4)
                    (1) edge node[fill=white] {$4$} (3)
                    (1) edge node[fill=white] {$2$} (4)
                    (2) edge node[fill=white] {$3$} (5)
                    (2) edge[line width=1.3pt] node[fill=white] {$4$} (3)
                    (5) edge[line width=1.3pt] node[fill=white] {$6$} (4);
        
        \node[]     (l) [pos=-90:25mm from 0] {$c(\pi)=25$};
    \end{graph}}}
    \hspace{5mm}
    \subfloat[Prima sostituzione]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main]     (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main]     (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};
    
        \path[-]    (1) edge[line width=1.3pt] node[fill=white] {$3$} (2)
                    (1) edge[dashed] node[fill=white] {$7$} (5)
                    (2) edge node[fill=white] {$6$} (4)
                    (3) edge[line width=1.3pt] node[fill=white] {$8$} (5)
                    (3) edge[dashed] node[fill=white] {$5$} (4)
                    (1) edge node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge node[fill=white] {$3$} (5)
                    (2) edge[line width=1.3pt] node[fill=white] {$4$} (3)
                    (5) edge[line width=1.3pt] node[fill=white] {$6$} (4);
        
        \node[]     (l) [pos=-90:25mm from 0] {$c(\pi)=23$};
    \end{graph}}}
    \hspace{5mm}
    \subfloat[Seconda sostituzione]{\resizebox*{0.3\textwidth}{!}{\begin{graph}
        \tikzset{
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }

        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main]     (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main]     (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};
    
        \path[-]    (1) edge[dashed] node[fill=white] {$3$} (2)
                    (1) edge node[fill=white] {$7$} (5)
                    (2) edge node[fill=white] {$6$} (4)
                    (3) edge[dashed] node[fill=white] {$8$} (5)
                    (3) edge node[fill=white] {$5$} (4)
                    (1) edge[line width=1.3pt] node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge[line width=1.3pt] node[fill=white] {$3$} (5)
                    (2) edge[line width=1.3pt] node[fill=white] {$4$} (3)
                    (5) edge[line width=1.3pt] node[fill=white] {$6$} (4);
        
        \node[]     (l) [pos=-90:25mm from 0] {$c(\pi)=19$};
    \end{graph}}}
\end{figure}

\noindent
Dopo due sostituzioni siamo arrivati a un minimo locale, che in questo caso è
anche globale visto che il costo del circuito finale è minimo.
\end{eg}

\paragraph{Complessità}
La \emph{complessità} di questo algoritmo dipende sia dal costo che paghiamo per
definire il circuito di partenza $\pi$ che dal costo che paghiamo per ricercare
una soluzione migliore nell'intorno di $\pi$. Nel primo caso possiamo usare uno
degli \emph{algoritmi greedy} appena descritti, mentre per esaminare l'intorno
paghiamo $O(n^2)$ perché il numero di coppia di \emph{archi} di un circuito è
$n(n-1)/2$ e di questi $n$ sono consecutivi. Di conseguenza, $|I_2(\pi)|
=n(n-1)/2-n=O(n^2)$.

\section{Algoritmi branch-\&-bound}
Gli \emph{algoritmi branch-\&-bound} sono molto simili agli \emph{algoritmi
backtrack}, ma introducono delle accortezze che permettono di ottenere
\q{potare} una parte più consistente dell'\emph{albero delle soluzioni}.

\begin{note}
    Per semplificare la trattazione, ipotizziamo che ogni sequenza di scelte
    abbia un costo non negativo e che quindi non sia possibile ridurre il costo
    di una soluzione parziale aggiungendo un'altra scelta alla sequenza.
    Inoltre, ci concentriamo solo su \emph{problemi di minimizzazione}.
\end{note}

\noindent
Lo strumento che questa tipologia di algoritmi usano per decidere che rami potare
è costituito dalle funzioni di \emph{upper bound} e \emph{lower bound}. Nei
\emph{problemi di minimizzazione}, l'\emph{upper bound} è definito come il
costo della soluzione ammissibile nota migliore. Il \emph{lower bound} è invece
calcolato mediante una funzione $lb$ con la seguente firma:
\[lb(\langle\emph{dati problema}\rangle,S,i,\langle\emph{dati parziali}\rangle)\]
Tale funzione deve essere definita in modo che il proprio valore dipenda dalla
sequenza $S[1\dots i]$ di scelte fatte e che il costo tutte le scelte
ammissibili generabili da quella sequenza sia maggiore di quello calcolato.

Se il \emph{lower bound} calcolato per una soluzione parziale è maggiore o
uguale all'\emph{upper bound}, l'\emph{albero} radicato in quella soluzione può
essere potato in quanto il suo costo sarà maggiore di quello della soluzione
ottimale.

\begin{note}
    È importante esplicitare che l'utilizzo di tecniche di potatura di questo
    tipo non abbassa la \emph{complessità} della soluzione, ma ne riduce
    comunque il tempo d'esecuzione. Ovviamente, maggiore è l'accuratezza di
    $lb$, maggiore è la porzione di \emph{albero} ad essere potata.
\end{note}

\subsection{Schema generale}
\begin{minicode}{Schema generale per algoritmi branch-\&-bound}
\ind branch\&bound($\langle$dati problema$\rangle$, \bc{ITEM}[] S, \bc{int} i, $\langle$dati parziali$\rangle$)\\
    \bc{SET} C = choices($\langle$dati problema$\rangle$, S, i, $\langle$dati parziali$\rangle$)\\
    \indf foreach (c $\in$ C) do\\
        S[i] = c\\
        \bc{int} lb = lb($\langle$dati problema$\rangle$, S, i, $\langle$dati parziali$\rangle$)\\
        \indff if (lb < minCost) then\hfill\com{Se false, pota l'\emph{albero}}
            \indfff if (i < n) then\\
                branch\&bound($\langle$dati problema$\rangle$, S, i + 1, $\langle$dati parziali$\rangle$)\\
            \indfff else\hfill\com{Valuta il costo della soluzione ammissibile trovata}
                \indffff if (cost(S, i) < minCost) then\\
                    minSol = S\hfill\com{Variabile globale}
                    minCost = cost(s, i)\hfill\com{Variabile globale}
\end{minicode}

\subsection{Problema del commesso viaggiatore}
Se $n$ sono le città da visitare e $d[h][k]$ è la distanza tra $h$ e $k$ espressa
come valore naturale, al passo $i$-esimo sono state fatte le scelte $S[1\dots i]$,
ovvero sono state visitate $i$ città prese dall'insieme $\{1,\dots,n\}$.

\bigskip\noindent
Ciò che dobbiamo fare adesso è trovare un'implementazione di $lb$ che ci
permetta di potare il più possibile.

\paragraph{Lower bound come costo effettivo della soluzione parziale}
\begin{definition}[Costo effettivo della soluzione parziale]
    Definiamo $cost[i]$ come la somma del peso degli archi percorsi nei primi
    $i$ passi, ovvero:
    \[cost[i]=\sum_{h=2}^id[S[h-1]][S[h]]\]
\end{definition}
\noindent
La cosa più facile è definire $lb$ come:
\[lb(d,S,i)=cost[i]\]

\begin{figure}[h!]
    \centering
    \scalebox{0.9}{\begin{graph}
        \tikzset{
            cell/.style={rectangle, draw, minimum size=15mm, inner sep=0},
            tips=proper
        }

        \def\labels{1 2 {\dots} i-1 i}
        \readarray\labels\la[1,5]

        \node[cell] (1) at (1,0) [label=above:{$\la[1,1]$}, label=left:{$S$}] {};
        \foreach \x in {2,...,5} {
            \FPeval{\p}{clip(\x+0.5*(\x-1))}
            \node[cell] (\x) at (\p,0) [label=above:{$\la[1,\x]$}] {};
            \ifthenelse{\x > 2}{
                \FPeval{\p}{clip(\x-1)}
                \draw[->] (\p.center) -- ++(0:14mm);
            }{
                \draw[->] (1.center) edge node[midway, below, xshift=-0.6mm]
                    {$d[S[1]][S[2]]$} ++(0:14mm);
            }
        }

        \path (1.south west)
        edge[decorate,decoration={brace,mirror,raise=.15cm}, line width=1pt]
        node[below=6pt] {$cost[i]$} (1.south west -| 5.south east);
    \end{graph}}
    \caption{Costo effettivo della soluzione parziale}
\end{figure}

\paragraph{Lower bound come costo per uscire dall'ultimo nodo}
\begin{definition}[Costo per uscire dall'ultimo nodo]
    Definiamo $out[S[i]]$ come il minimo fra i pesi degli archi che escono da
    $S[i]$ e vanno in uno dei nodi non ancora scelti, ovvero:
    \[out[S[i]]=\min_{k\notin s[1\dots i]}d[S[i]][k]\]
\end{definition}

\noindent
Noto il valore $out[S[i]]$, $lb$ può essere definito come:
\[lb(d,S,i)=cost[i]+out[S[i]]\]

\newpage
\begin{figure}[ht!]
    \centering
    \scalebox{0.9}{\begin{graph}
        \tikzset{
            cell/.style={rectangle, draw, minimum size=15mm, inner sep=0},
            tips=proper
        }

        \def\labels{1 2 {\dots} i-1 i}
        \readarray\labels\la[1,5]

        \node[cell] (1) at (1,0) [label=above:{$\la[1,1]$}, label=left:{$S$}] {};
        \foreach \x in {2,...,5} {
            \FPeval{\p}{clip(\x+0.5*(\x-1))}
            \node[cell] (\x) at (\p,0) [label=above:{$\la[1,\x]$}] {};
            \ifthenelse{\x > 2}{
                \FPeval{\p}{clip(\x-1)}
                \draw[->] (\p.center) -- ++(0:14mm);
            }{
                \draw[->] (1.center) edge node[midway, below, xshift=-0.6mm]
                    {$d[S[1]][S[2]]$} ++(0:14mm);
            }
        }

        \path (1.south west)
        edge[decorate,decoration={brace,mirror,raise=.15cm}, line width=1pt]
        node[below=6pt] {$cost[i]$} (1.south west -| 5.south east);

        \draw[->] (5.20) -- ++(20:14mm);
        \draw[->] (5.10) -- ++(10:14mm);
        \draw[->] (5.0) -- ++(0:14mm);
        \draw[->] (5.-10) edge[line width=1.3pt] ++(-10:14mm);
        \draw[->] (5.-20) edge node[midway, below, yshift=-4.6mm] {$out[S[i]]$} ++(-20:14mm);
    \end{graph}}
    \caption{Costo per uscire da un \emph{nodo}}
\end{figure}

\paragraph{Lower bound come costo per uscire da tutti i nodi rimasti}
\begin{definition}[Costo per uscire da tutti i nodi rimasti]
    Per ogni nodo $h$ non ancora scelto, sommiamo il minimo tra i pesi degli
    archi che escono da esso e vanno in $S[1]$ o in un nodo non ancora scelto,
    ovvero:
    \[out[h]=\min_{k\notin S[2\dots i]}d[h][k]\quad\forall k\notin S[1\dots i]\]
\end{definition}

\noindent
Noto il valore $out[S[i]]$, $lb$ può essere definito come:
\[lb(d,S,i)=cost[i]+out[S[i]]+\sum_{h\notin S[1\dots i]}out[h]\]

\begin{figure}[ht!]
    \centering
    \resizebox{\textwidth}{!}{\begin{graph}
        \tikzset{
            cell/.style={rectangle, draw, minimum size=15mm, inner sep=0},
            tips=proper
        }

        \def\labels{1 2 {\dots} i-1 i}
        \readarray\labels\la[1,5]

        \node[cell] (1) at (1,0) [label=above:{$\la[1,1]$}, label=left:{$S$}] {};
        \foreach \x in {2,...,5} {
            \FPeval{\p}{clip(\x+0.5*(\x-1))}
            \node[cell] (\x) at (\p,0) [label=above:{$\la[1,\x]$}] {};
            \ifthenelse{\x > 2}{
                \FPeval{\p}{clip(\x-1)}
                \draw[->] (\p.center) -- ++(0:14mm);
            }{
                \draw[->] (1.center) edge node[midway, below, xshift=-0.6mm]
                    {$d[S[1]][S[2]]$} ++(0:14mm);
            }
        }

        \path (1.south west)
        edge[decorate,decoration={brace,mirror,raise=.15cm}, line width=1pt]
        node[below=6pt] {$cost[i]$} (1.south west -| 5.south east);

        \draw[->] (5.20) -- ++(20:14mm);
        \draw[->] (5.10) -- ++(10:14mm);
        \draw[->] (5.0) -- ++(0:14mm);
        \draw[->] (5.-10) edge[line width=1.3pt] ++(-10:14mm);
        \draw[->] (5.-20) edge node[midway, below, yshift=-4.6mm] {$out[S[i]]$} ++(-20:14mm);

        \def\hs{h_1 h_2 {\dots} h_{n-1}}
        \readarray\hs\h[1, 4]
        \def\modules{3 2 1 5}
        \readarray\modules\m[1, 4]
        \def\degrees{20 10 0 -10 -20}
        \readarray\degrees\de[1, 5]
        
        \foreach \x in {1,...,4} {
            \FPeval{\n}{clip(\x+5)}
            \FPeval{\p}{clip(5+\x*2+0.5*(5+\x*2-1))}
            \node[cell] (\n) at (\p,0) {$\h[1,\x]$};

            \foreach \edge in {1,...,5} {
                \ifthenelse{\edge = \m[1,\x]}{
                    \ifthenelse{\de[1,\edge] = -20}{
                        \draw[->] (\n.\de[1,\edge]) edge[line width=1.3pt]
                        node[midway, below, yshift=-4.6mm] {$out[S[\h[1,\x]]]$} ++(\de[1,\edge]:14mm);
                    }{
                        \draw[->] (\n.\de[1,\edge]) edge[line width=1.3pt] ++(\de[1,\edge]:14mm);
                    }
                }{
                    \ifthenelse{\de[1,\edge] = -20}{
                        \draw[->] (\n.\de[1,\edge]) edge node[midway, below, yshift=-4.6mm]
                        {$out[S[\h[1,\x]]]$} ++(\de[1,\edge]:14mm);
                    }{
                        \draw[->] (\n.\de[1,\edge]) -- ++(\de[1,\edge]:14mm);
                    }
                }
            }
        }
    \end{graph}}
    \caption{Costo per uscire da tutti i \emph{nodi} rimasti}
\end{figure}

\paragraph{Lower bound come costo per attraversare i nodi non ancora scelti}
\begin{definition}[Costo per attraversare i nodi non ancora scelti]
    Per ogni non $h$ non ancora scelto, calcoliamo il costo di attraversamento
    $transfer[h]$ come la somma tra i pesi minimi di due archi $(p,h)$ e $(h,q)$
    che entrano ed escono da $h$ andando in $S[1]$ un in nodo non ancora scelto.
    La definizione di $transfer[h]$ è quindi la seguente:
    \[transfer[h]=\min{}_{p\notin S[1\dots i-1],q\notin S[2\dots i]\::\:p\neq
    q\neq h}\{d[p][h]+d[h][q]\}\]
\end{definition}
\begin{definition}[Costo per tornare al primo nodo]
    Definiamo il valore $last$ come il minimo tra i pesi degli archi che vanno
    da uno dei nodi non ancora scelti in $S[1]$, ovvero:
    \[last=\min_{h\notin S[1\dots n]}d[h][S[1]]\]
\end{definition}

\noindent
A questo punto, definiamo $lb$ come:
\[lb(d,S,i)=cost[i]+\left\lceil\frac{out[S[i]]+\sum_{h\notin S}transfer[h]+last}{2}\right\rceil\]
Stiamo dividendo per $2$ perché il peso di ogni \emph{arco} viene contato due volte:
in ingresso e in uscita.

\begin{figure}[ht!]
    \centering
    \resizebox{\textwidth}{!}{\begin{graph}
        \tikzset{
            cell/.style={rectangle, draw, minimum size=15mm, inner sep=0},
            tips=proper
        }

        \def\labels{1 2 {\dots} i-1 i}
        \readarray\labels\la[1,5]

        \node[cell] (1) at (1,0) [label=above:{$\la[1,1]$}, label=left:{$S$}] {};
        \foreach \x in {2,...,5} {
            \FPeval{\p}{clip(\x+0.5*(\x-1))}
            \node[cell] (\x) at (\p,0) [label=above:{$\la[1,\x]$}] {};
            \ifthenelse{\x > 2}{
                \FPeval{\p}{clip(\x-1)}
                \draw[->] (\p.center) -- ++(0:14mm);
            }{
                \draw[->] (1.center) edge node[midway, below, xshift=-0.6mm]
                    {$d[S[1]][S[2]]$} ++(0:14mm);
            }
        }

        \path (1.south west)
        edge[decorate,decoration={brace,mirror,raise=.15cm}, line width=1pt]
        node[below=6pt] {$cost[i]$} (1.south west -| 5.south east);

        \draw[->] (5.20) -- ++(20:14mm);
        \draw[->] (5.10) -- ++(10:14mm);
        \draw[->] (5.0) -- ++(0:14mm);
        \draw[->] (5.-10) edge[line width=1.3pt] ++(-10:14mm);
        \draw[->] (5.-20) edge node[midway, below, yshift=-4.6mm] {$out[S[i]]$} ++(-20:14mm);

        \FPeval{\p}{clip(7+0.5*(6))}
        \node[rectangle, minimum size=15mm] (6) at (\p,0) {\dots};
        \FPeval{\p}{clip(9+0.5*(8))}
        \node[cell] (7) at (\p,0) [label={[yshift=-2.5mm]below:{$transfer[h]$}}] {$h$};
        \FPeval{\p}{clip(11+0.5*(10))}
        \node[rectangle, minimum size=15mm] (8) at (\p,0) {\dots};
        \FPeval{\p}{clip(13+0.5*(12))}
        \node[cell] (9) at (\p,0) [label={[yshift=-2.5mm]below:{$last$}}] {$S[1]$};

        \draw[->] (7.20) -- ++(20:14mm);
        \draw[->] (7.10) -- ++(10:14mm);
        \draw[->] (7.0) -- ++(0:14mm);
        \draw[->] (7.-10) edge[line width=1.3pt] ++(-10:14mm);
        \draw[->] (7.-20) -- ++(-20:14mm);

        \draw[<-] (7.150) -- ++(160:14mm);
        \draw[<-] (7.165) edge[line width=1.3pt] ++(170:14mm);
        \draw[<-] (7.180) -- ++(180:14mm);
        \draw[<-] (7.195) -- ++(190:14mm);
        \draw[<-] (7.210) -- ++(200:14mm);

        \draw[<-] (9.150) -- ++(160:14mm);
        \draw[<-] (9.165) -- ++(170:14mm);
        \draw[<-] (9.180) edge[line width=1.3pt] ++(180:14mm);
        \draw[<-] (9.195) -- ++(190:14mm);
        \draw[<-] (9.210) -- ++(200:14mm);
    \end{graph}}
    \caption{Costo per attraversare tutti i \emph{nodi} rimasti}
\end{figure}

\begin{minicode}{Implementazione delle soluzione}
\ind bbTsp(\bc{ITEM}[] S, \bc{int} cost, \bc{SET} R, \bc{int} n, \bc{int} i)\\
    \bc{SET} choices = copy(R)\\
    \indf foreach (c $\in$ choices) do\\
        S[i] = c\\
        R.remove(c)\\
        \indff if (i < n) then\\
            \{ Calcola $out$, $last$ e $transfer[h]$ per ogni $h\in R$ \}\\
            \bc{int} lb = cost[i] + $\lceil$(out + $\sum_{h\notin S}$transfer[h] + last) / 2$\rceil$\\
            \indfff if (lb < minCost) then\\
                bbTsp(S, cost + d[S[i - 1]][S[i]], R, n, i + 1)\\
        \indff else\\
            cost = cost + d[S[i]][S[1]]\\
            \indfff if (cost < minCost) then\\
                minSol = S\\
                minCost = cost\\
        \indff R.insert(c)
\end{minicode}

\noindent
Invece di inizializzare la variabile globale \texttt{minCost} a $+\infty$,
possiamo partire da una permutazione qualsiasi dei \emph{nodi}. Inoltre, per
evitare di generare più volte lo stesso circuito, possiamo decidere di iniziare
sempre dello stesso \emph{nodo}.

\paragraph{Complessità}
Come accennato all'inizio della sezione, l'utilizzo delle funzioni \emph{upper
bound} e \emph{lower bound} non migliorano la \emph{complessità}, che rimane
quella di una soluzione con \emph{backtracking}.

\begin{eg}[Esempio d'esecuzione]
Consideriamo lo stesso grafo completo degli esempi precedenti e scegliamo un
circuito iniziale che parte da $1$, per esempio:
\[S=\{1,2,5,3,4\}\]
Il costo di questo percorso è $21$, quindi $minCost=21$ costituisce il nostro
primo upper bound.

\newpage
\begin{figure}[ht!]
    \centering
    \scalebox{0.85}{\begin{graph}
        \tikzset{
            cell/.style={rectangle, draw, minimum size=10mm, font=\large},
            empty/.style={inner sep=0},
            pos/.style args={#1:#2 from #3}{
                at=(#3.#1), anchor=#1+180, shift=(#1:#2)
            }
        }
    
        \def\labels{1 2 3 4 5}
        \def\numbers{%
            0 3 4 2 7
            3 0 4 6 3
            4 4 0 5 8
            2 6 5 0 6
            7 3 8 6 0
        }
        \readarray\labels\la[1,5]
        \readarray\numbers\num[5,5]
    
        \foreach \x in {1,...,5}
            \foreach \y in {1,...,5}
            {
                \ifthenelse{\x = 1\and\y=1}{
                    \node[cell] (\x\y) at (\x-1,-\y+1) [label=above:{$\la[1,1]$},
                    label=left:{$\la[1,1]$}] {};
                }{
                    \ifthenelse{\x=1}{
                        \node[cell] (\x\y) at (\x-1,-\y+1) [label=left:{$\la[1,\y]$}]
                        {$\num[\x,\y]$};
                    }{
                        \ifthenelse{\y = 1}{
                            \node[cell] (\x\y) at (\x-1,-\y+1)[label=above:{$\la[1,\x]$}]
                            {$\num[\x,\y]$};
                        }{
                            \ifthenelse{\num[\x,\y]=0}{
                                \node[cell] (\x\y) at (\x-1,-\y+1) {};
                            }{
                                \node[cell] (\x\y) at (\x-1,-\y+1) {$\num[\x,\y]$};
                            }
                        }
                    }    
                }
            }
    
        \node[empty]    (0) [right of=53, shift={(30mm,-2.5mm)}] {};
        \node[main]     (1) [pos=90:20mm from 0] {$1$};
        \node[main]     (2) [pos=18:20mm from 0] {$2$};
        \node[main]     (3) [pos=-54:20mm from 0] {$3$};
        \node[main]     (4) [pos=-126:20mm from 0] {$4$};
        \node[main]     (5) [pos=-198:20mm from 0] {$5$};
    
        \path[-]    (1) edge[line width=1.3pt] node[fill=white] {$3$} (2)
                    (1) edge node[fill=white] {$7$} (5)
                    (2) edge node[fill=white] {$6$} (4)
                    (3) edge[line width=1.3pt] node[fill=white] {$8$} (5)
                    (3) edge[line width=1.3pt] node[fill=white] {$5$} (4)
                    (1) edge node[fill=white] {$4$} (3)
                    (1) edge[line width=1.3pt] node[fill=white] {$2$} (4)
                    (2) edge[line width=1.3pt] node[fill=white] {$3$} (5)
                    (2) edge node[fill=white] {$4$} (3)
                    (5) edge node[fill=white] {$6$} (4);
    \end{graph}}
\end{figure}

\noindent
Proviamo a vedere quali rami dell'albero delle soluzioni vengono potati con
questi parametri iniziali:

\begin{figure}[h!]
\centering
\resizebox*{\textwidth}{!}{\begin{graph}
    \newcommand{\cont}[2]{\shortstack{$#1$\\\\$#2$}}
    \tikzset{
        cell/.style={ellipse, draw, minimum width=10mm, minimum height=15mm}
    }
    \node[cell] (0) [label=above:{$1$}] {\cont{21}{18}};

    \node[cell] (l) [right of=0, xshift=50mm] {\cont{UB}{LB}};

    \node[cell] (1) [below of=0, yshift=-5mm, xshift=-70mm] {\cont{21}{18}};
    \node[cell] (2) [below of=0, yshift=-5mm, xshift=-7.5mm] {\cont{21}{18}};
    \node[cell] (3) [below of=0, yshift=-5mm, xshift=45mm] {\cont{19}{18}};
    \node[cell] (4) [below of=0, yshift=-5mm, xshift=75mm] {\cont{19}{18}};

    \node[cell] (5) [below of=1, yshift=-5mm, xshift=-15mm] {\cont{21}{21}};
    \node[cell] (6) [below of=1, yshift=-5mm] {\cont{21}{22}};
    \node[cell] (7) [below of=1, yshift=-5mm, xshift=15mm] {\cont{21}{18}};

    \node[cell] (8) [below of=7, yshift=-5mm, xshift=-7.5mm] {\cont{21}{21}};
    \node[cell] (9) [below of=7, yshift=-5mm, xshift=7.5mm] {\cont{21}{21}};

    \node[cell] (10) [below of=2, yshift=-5mm, xshift=-15mm] {\cont{21}{19}};
    \node[cell] (11) [below of=2, yshift=-5mm] {\cont{19}{21}};
    \node[cell] (12) [below of=2, yshift=-5mm, xshift=15mm] {\cont{19}{21}};

    \node[cell] (13) [below of=10, yshift=-5mm, xshift=-7.5mm] {\cont{21}{25}};
    \node[cell] (14) [below of=10, yshift=-5mm, xshift=7.5mm] {\cont{21}{19}};

    \node[cell] (15) [below of=14, yshift=-5mm, label=right:{$minCost=19$}] {\cont{19}{19}};

    \node[cell] (16) [below of=3, yshift=-5mm, xshift=-20mm] {\cont{19}{20}};
    \node[cell] (17) [below of=3, yshift=-5mm, xshift=-5mm] {\cont{19}{18}};
    \node[cell] (18) [below of=3, yshift=-5mm, xshift=25mm] {\cont{19}{18}};

    \node[cell] (19) [below of=17, yshift=-5mm, xshift=-7.5mm] {\cont{19}{21}};
    \node[cell] (20) [below of=17, yshift=-5mm, xshift=7.5mm] {\cont{19}{21}};

    \node[cell] (21) [below of=18, yshift=-5mm, xshift=-7.5mm] {\cont{19}{19}};
    \node[cell] (22) [below of=18, yshift=-5mm, xshift=7.5mm] {\cont{19}{24}};

    \path[-]    (0)     edge node[midway, above] {$2$} (1)
                (0)     edge node[midway, right] {$3$} (2)
                (0)     edge node[midway, above, shift={(2.5mm,-2mm)}] {$4$} (3)
                (0)     edge node[midway, above] {$5$} (4)
                (1)     edge node[midway, left] {$3$} (5)
                (1)     edge node[midway, right] {$4$} (6)
                (1)     edge node[midway, right] {$5$} (7)
                (7)     edge node[midway, left] {$3$} (8)
                (7)     edge node[midway, right] {$4$} (9)
                (2)     edge node[midway, left] {$2$} (10)
                (2)     edge node[midway, right] {$4$} (11)
                (2)     edge node[midway, right] {$5$} (12)
                (10)     edge node[midway, left] {$4$} (13)
                (10)     edge node[midway, right] {$5$} (14)
                (14)     edge node[midway, left] {$4$} (15)
                (3)     edge node[midway, left] {$2$} (16)
                (3)     edge node[midway, right] {$3$} (17)
                (3)     edge node[midway, right, xshift=1mm] {$5$} (18)
                (17)     edge node[midway, left] {$2$} (19)
                (17)     edge node[midway, right] {$5$} (20)
                (18)     edge node[midway, left] {$2$} (21)
                (18)     edge node[midway, right] {$3$} (22);
\end{graph}}
\end{figure}

\noindent
In questo caso siamo riusciti a potare $42$ nodi su un totale di $65$.
\end{eg}