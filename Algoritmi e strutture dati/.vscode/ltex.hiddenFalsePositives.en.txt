{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q(c); .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[<-, bend right=15] (1) edge (2) (2) edge (3) (3) edge (4) (3) edge (5) (5) edge (6) (5) edge (7); .\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q[main] (1) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.; [main] (2) [below right of=1, shift=(15mm, 3mm).]\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.; [main] (3) [below of=2, shift=(3mm, 0mm).]\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.; [main] (4) [left of=3, shift=(-20mm, -1mm).]\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.; [main] (5) [right of=3, shift=(20mm, 7mm).]\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.; [main] (6) [below right of=5, shift=(6mm, 6mm).]\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.; [main] (7) [above of=6, shift=(5mm, 10mm).]\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QSe invece il vettore \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q fosse popolato interamente di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, ad ogni livello della ricorsione si realizzerebbero due chiamate, portando quindi la complessità a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"AI","sentence":"^\\QSia \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q il problema \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q ristretto ai dati di input per i quali \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q è limitato superiormente da \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, con \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q funzione polinomiale di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"INTERJECTIONS_PUNCTUATION","sentence":"^\\Qha complessità.\\E$"}
{"rule":"CONFUSION_DUE_DO","sentence":"^\\Qdue volte, prima in un senso e poi nell'altro, otteniamo un circuito di costo \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q nel quale ogni nodo.\\E$"}
{"rule":"ARROWS","sentence":"^\\Q[->, bend left=15] (1) edge (2) (2) edge (3) (3) edge (4) (3) edge (5) (5) edge (6) (5) edge (7);\\E$"}
{"rule":"ARROWS","sentence":"^\\Q[<-, bend right=15] (1) edge (2) (2) edge (3) (3) edge (4) (3) edge (5) (5) edge (6) (5) edge (7); .\\E$"}
{"rule":"NE","sentence":"^\\Qdopo l'\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q-esimo, ma questo tipo di accorgimenti non cambiano le dinamiche generali dell'algoritmo, e soprattutto non ne modificano la complessità..\\E$"}
{"rule":"NE","sentence":"^\\Qdella soluzione, ma ne riduce comunque il tempo d'esecuzione.\\E$"}
{"rule":"NON_ANTI_JJ","sentence":"^\\QPer ogni valore di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q otteniamo: \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Non tutti i tagli di monete permettono di utilizzare la programmazione greedy.\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qin 0,...,14 in 1,...,11 = 14 = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=-3.5mm]below right:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 11 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  [cell] () at (,-) ;\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"NE","sentence":"^\\QInoltre, poiché \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q è l'intervallo con il minor tempo di fine, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q e quindi, ne consegue che \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"THE_PUNCT","sentence":"^\\QSET indipendentSet(int[] a, int[] b) Ordina i vettori \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q e \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q in modo che \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q SET S = Set() S.insert(1) int last = 1 for (i = 2 to n) do if (a[i] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q b[last]) then S.insert(i) last = i return S\\E$"}
{"rule":"I_LOWERCASE","sentence":"^\\QSET indipendentSet(int[] a, int[] b) Ordina i vettori \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q e \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q in modo che \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q SET S = Set() S.insert(1) int last = 1 for (i = 2 to n) do if (a[i] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q b[last]) then S.insert(i) last = i return S\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qin 0,...,14 in 1,...,11 = 14 = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=-3.5mm]below right:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 11 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 1 [cell] () at (,-) [label=[red]left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  [cell] () at (,-) ; [<->] (11.west) edge[line width=1.5pt, red] (31.east) (32.west) edge[line width=1.5pt, dashed] (42.east) (03.west) edge[line width=1.5pt, dashed] (53.east) (54.west) edge[line width=1.5pt] (74.east) (35.west) edge[line width=1.5pt, dashed] (75.east) (56.west) edge[line width=1.5pt] (86.east) (67.west) edge[line width=1.5pt] (97.east) (88.west) edge[line width=1.5pt] (108.east) (89.west) edge[line width=1.5pt] (119.east) (210.west) edge[line width=1.5pt, dashed] (1210.east) (1211.west) edge[line width=1.5pt] (1311.east);; 0.48 !\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qin 0,...,14 in 1,...,11 = 14 = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=-3.5mm]below right:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 11 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 4 [cell] () at (,-) [label=[red]left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  [cell] () at (,-) ; [<->] (11.west) edge[line width=1.5pt, red] (31.east) (32.west) edge[line width=1.5pt, dashed] (42.east) (03.west) edge[line width=1.5pt, dashed] (53.east) (54.west) edge[line width=1.5pt, red] (74.east) (35.west) edge[line width=1.5pt, dashed] (75.east) (56.west) edge[line width=1.5pt, dashed] (86.east) (67.west) edge[line width=1.5pt, dashed] (97.east) (88.west) edge[line width=1.5pt] (108.east) (89.west) edge[line width=1.5pt] (119.east) (210.west) edge[line width=1.5pt, dashed] (1210.east) (1211.west) edge[line width=1.5pt] (1311.east);; 0.48 !\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qin 0,...,14 in 1,...,11 = 14 = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=-3.5mm]below right:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 11 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 8 [cell] () at (,-) [label=[red]left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  [cell] () at (,-) ; [<->] (11.west) edge[line width=1.5pt, red] (31.east) (32.west) edge[line width=1.5pt, dashed] (42.east) (03.west) edge[line width=1.5pt, dashed] (53.east) (54.west) edge[line width=1.5pt, red] (74.east) (35.west) edge[line width=1.5pt, dashed] (75.east) (56.west) edge[line width=1.5pt, dashed] (86.east) (67.west) edge[line width=1.5pt, dashed] (97.east) (88.west) edge[line width=1.5pt, red] (108.east) (89.west) edge[line width=1.5pt, dashed] (119.east) (210.west) edge[line width=1.5pt, dashed] (1210.east) (1211.west) edge[line width=1.5pt] (1311.east);; 0.487 !\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qin 0,...,14 in 1,...,11 = 14 = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=-3.5mm]below right:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 11 [cell] () at (,-) [label=[red]left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  [cell] () at (,-) ; [<->] (11.west) edge[line width=1.5pt, red] (31.east) (32.west) edge[line width=1.5pt, dashed] (42.east) (03.west) edge[line width=1.5pt, dashed] (53.east) (54.west) edge[line width=1.5pt, red] (74.east) (35.west) edge[line width=1.5pt, dashed] (75.east) (56.west) edge[line width=1.5pt, dashed] (86.east) (67.west) edge[line width=1.5pt, dashed] (97.east) (88.west) edge[line width=1.5pt, red] (108.east) (89.west) edge[line width=1.5pt, dashed] (119.east) (210.west) edge[line width=1.5pt, dashed] (1210.east) (1211.west) edge[line width=1.5pt, red] (1311.east);;\\E$"}
{"rule":"NON_STANDARD_WORD","sentence":"^\\Q[main] (a) [label=above:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, yshift=-8mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (b) [label=above:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, right of=a] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (c) [label=above:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, right of=b] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (d) [label=above:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, right of=c] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (e) [label=above:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, right of=d] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (f) [label=above:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, right of=e] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;\\E$"}
{"rule":"THE_PUNCT","sentence":"^\\Q[Albero di copertura dei cammini minimi] [main, line width=1.3pt] (a) [label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (b) [right of=a, label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, xshift=10mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (c) [below of=b, label=below:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, yshift=-10mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (d) [left of=c, label=below:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, xshift=-10mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [->] (a) edge[line width=1.3pt] node[above] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (b) (b) edge[line width=1.3pt] node[right] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (c) (a) edge[line width=1.3pt] node[left] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (d); [-] (d) edge node[below] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (c); [Albero di copertura di peso minimo] [main, line width=1.3pt] (a) [label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (b) [right of=a, label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, xshift=10mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (c) [below of=b, label=below:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, yshift=-10mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (d) [left of=c, label=below:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, xshift=-10mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [->] (a) edge[line width=1.3pt] node[above] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (b) (b) edge[line width=1.3pt] node[right] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (c) (c) edge[line width=1.3pt] node[below] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (d); [-] (a) edge node[left] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (d); Albero di copertura dei cammini minimi e di peso minimo\\E$"}
{"rule":"MA_MY","sentence":"^\\QPoiché \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, ma dato che \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q è un albero di copertura minimo, vale anche \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QV() - r) do pos[u] = Q.insert(u, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) pos[r] = Q.insert(r, 0) p[r] = 0 while (not Q.isEmpty()) do NODE u = Q.deleteMin() pos[u] = nil foreach (v \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q G.adj(u)) do if (pos[v] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q nil and G.w(u, v) < pos[v].priority) then Q.decrease(pos[v], G.w(u, v)) p[v] = u return p\\E$"}
{"rule":"PRP_VB","sentence":"^\\QI nodi rossi rappresentano il punto in cui il valore di missing arriva a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q per la prima volta nel cammino radice-foglia.\\E$"}
{"rule":"ACCEPT_EXCEPT","sentence":"^\\Qenumeration(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, ITEM[] S, int i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Verifica se \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q contiene una soluzione ammissibile if (accept(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)) Processa la soluzione (e.g. stampa, conta, …) processSolution(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Verifica se \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q contiene una soluzione non ammissibile else if (reject(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)) then return else Calcola l'insieme delle scelte in funzione di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q SET C = choices(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Itera sull'insieme delle scelte foreach (c \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q C) do S[i] = c Chiamata ricorsiva enumeration(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i + 1, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)\\E$"}
{"rule":"ACCEPT_EXCEPT","sentence":"^\\Qboolean enumeration(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, ITEM[] S, int i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Verifica se \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q contiene una soluzione ammissibile if (accept(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)) Processa la soluzione (e.g. stampa, conta, …) processSolution(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) return true Verifica se \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q contiene una soluzione non ammissibile else if (reject(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)) return false else Calcola l'insieme delle scelte in funzione di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q SET C = choices(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Itera sull'insieme delle scelte foreach (c \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q C) do S[i] = c Chiamata ricorsiva if (enumeration(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i + 1, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)) then return true return false\\E$"}
{"rule":"ACCEPT_EXCEPT","sentence":"^\\Qenumeration(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, ITEM[] S, int i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Verifica se \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q contiene una soluzione ammissibile if (accept(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)) Processa la soluzione (e.g. stampa, conta, …) processSolution(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) else Calcola l'insieme delle scelte in funzione di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q SET C = choices(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Itera sull'insieme delle scelte foreach (c \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q C) do S[i] = c Chiamata ricorsiva enumeration(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i + 1, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)\\E$"}
{"rule":"NON_ANTI_JJ","sentence":"^\\QLe definizione appena enunciata afferma che nel caso in cui, ad esempio, si stia ordinando per anno di corso una lista di studenti già ordinata alfabeticamente, un metodo stabile produce una lista in cui gli alunni dello stesso anno sono ancora in ordine alfabetico, mentre un ordinamento non stabile probabilmente produrrà una lista senza più alcuna traccia del precedente ordinamento.\\E$"}
