{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q(c); .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[<-, bend right=15] (1) edge (2) (2) edge (3) (3) edge (4) (3) edge (5) (5) edge (6) (5) edge (7); .\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q[main] (1) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.; [main] (2) [below right of=1, shift=(15mm, 3mm).]\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.; [main] (3) [below of=2, shift=(3mm, 0mm).]\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.; [main] (4) [left of=3, shift=(-20mm, -1mm).]\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.; [main] (5) [right of=3, shift=(20mm, 7mm).]\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.; [main] (6) [below right of=5, shift=(6mm, 6mm).]\\E$"}
{"rule":"UNIT_SPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.; [main] (7) [above of=6, shift=(5mm, 10mm).]\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QSe invece il vettore \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q fosse popolato interamente di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, ad ogni livello della ricorsione si realizzerebbero due chiamate, portando quindi la complessità a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"AI","sentence":"^\\QSia \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q il problema \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q ristretto ai dati di input per i quali \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q è limitato superiormente da \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, con \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q funzione polinomiale di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"INTERJECTIONS_PUNCTUATION","sentence":"^\\Qha complessità.\\E$"}
{"rule":"CONFUSION_DUE_DO","sentence":"^\\Qdue volte, prima in un senso e poi nell'altro, otteniamo un circuito di costo \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q nel quale ogni nodo.\\E$"}
{"rule":"ARROWS","sentence":"^\\Q[->, bend left=15] (1) edge (2) (2) edge (3) (3) edge (4) (3) edge (5) (5) edge (6) (5) edge (7);\\E$"}
{"rule":"ARROWS","sentence":"^\\Q[<-, bend right=15] (1) edge (2) (2) edge (3) (3) edge (4) (3) edge (5) (5) edge (6) (5) edge (7); .\\E$"}
{"rule":"NE","sentence":"^\\Qdopo l'\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q-esimo, ma questo tipo di accorgimenti non cambiano le dinamiche generali dell'algoritmo, e soprattutto non ne modificano la complessità..\\E$"}
{"rule":"NE","sentence":"^\\Qdella soluzione, ma ne riduce comunque il tempo d'esecuzione.\\E$"}
{"rule":"NON_ANTI_JJ","sentence":"^\\QPer ogni valore di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q otteniamo: \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Non tutti i tagli di monete permettono di utilizzare la programmazione greedy.\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qin 0,...,14 in 1,...,11 = 14 = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=-3.5mm]below right:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 11 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  [cell] () at (,-) ;\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"NE","sentence":"^\\QInoltre, poiché \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q è l'intervallo con il minor tempo di fine, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q e quindi, ne consegue che \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"THE_PUNCT","sentence":"^\\QSET indipendentSet(int[] a, int[] b) Ordina i vettori \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q e \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q in modo che \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q SET S = Set() S.insert(1) int last = 1 for (i = 2 to n) do if (a[i] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q b[last]) then S.insert(i) last = i return S\\E$"}
{"rule":"I_LOWERCASE","sentence":"^\\QSET indipendentSet(int[] a, int[] b) Ordina i vettori \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q e \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q in modo che \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q SET S = Set() S.insert(1) int last = 1 for (i = 2 to n) do if (a[i] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q b[last]) then S.insert(i) last = i return S\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qin 0,...,14 in 1,...,11 = 14 = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=-3.5mm]below right:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 11 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 1 [cell] () at (,-) [label=[red]left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  [cell] () at (,-) ; [<->] (11.west) edge[line width=1.5pt, red] (31.east) (32.west) edge[line width=1.5pt, dashed] (42.east) (03.west) edge[line width=1.5pt, dashed] (53.east) (54.west) edge[line width=1.5pt] (74.east) (35.west) edge[line width=1.5pt, dashed] (75.east) (56.west) edge[line width=1.5pt] (86.east) (67.west) edge[line width=1.5pt] (97.east) (88.west) edge[line width=1.5pt] (108.east) (89.west) edge[line width=1.5pt] (119.east) (210.west) edge[line width=1.5pt, dashed] (1210.east) (1211.west) edge[line width=1.5pt] (1311.east);; 0.48 !\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qin 0,...,14 in 1,...,11 = 14 = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=-3.5mm]below right:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 11 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 4 [cell] () at (,-) [label=[red]left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  [cell] () at (,-) ; [<->] (11.west) edge[line width=1.5pt, red] (31.east) (32.west) edge[line width=1.5pt, dashed] (42.east) (03.west) edge[line width=1.5pt, dashed] (53.east) (54.west) edge[line width=1.5pt, red] (74.east) (35.west) edge[line width=1.5pt, dashed] (75.east) (56.west) edge[line width=1.5pt, dashed] (86.east) (67.west) edge[line width=1.5pt, dashed] (97.east) (88.west) edge[line width=1.5pt] (108.east) (89.west) edge[line width=1.5pt] (119.east) (210.west) edge[line width=1.5pt, dashed] (1210.east) (1211.west) edge[line width=1.5pt] (1311.east);; 0.48 !\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qin 0,...,14 in 1,...,11 = 14 = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=-3.5mm]below right:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 11 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 8 [cell] () at (,-) [label=[red]left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  [cell] () at (,-) ; [<->] (11.west) edge[line width=1.5pt, red] (31.east) (32.west) edge[line width=1.5pt, dashed] (42.east) (03.west) edge[line width=1.5pt, dashed] (53.east) (54.west) edge[line width=1.5pt, red] (74.east) (35.west) edge[line width=1.5pt, dashed] (75.east) (56.west) edge[line width=1.5pt, dashed] (86.east) (67.west) edge[line width=1.5pt, dashed] (97.east) (88.west) edge[line width=1.5pt, red] (108.east) (89.west) edge[line width=1.5pt, dashed] (119.east) (210.west) edge[line width=1.5pt, dashed] (1210.east) (1211.west) edge[line width=1.5pt] (1311.east);; 0.487 !\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qin 0,...,14 in 1,...,11 = 14 = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=-3.5mm]below right:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 = 11 [cell] () at (,-) [label=[red]left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 11 [cell] () at (,-) [label=[xshift=3mm]below left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  = 0 [cell] () at (,-) [label=left:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] ;  [cell] () at (,-) ; [<->] (11.west) edge[line width=1.5pt, red] (31.east) (32.west) edge[line width=1.5pt, dashed] (42.east) (03.west) edge[line width=1.5pt, dashed] (53.east) (54.west) edge[line width=1.5pt, red] (74.east) (35.west) edge[line width=1.5pt, dashed] (75.east) (56.west) edge[line width=1.5pt, dashed] (86.east) (67.west) edge[line width=1.5pt, dashed] (97.east) (88.west) edge[line width=1.5pt, red] (108.east) (89.west) edge[line width=1.5pt, dashed] (119.east) (210.west) edge[line width=1.5pt, dashed] (1210.east) (1211.west) edge[line width=1.5pt, red] (1311.east);;\\E$"}
{"rule":"NON_STANDARD_WORD","sentence":"^\\Q[main] (a) [label=above:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, yshift=-8mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (b) [label=above:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, right of=a] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (c) [label=above:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, right of=b] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (d) [label=above:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, right of=c] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (e) [label=above:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, right of=d] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (f) [label=above:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, right of=e] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;\\E$"}
{"rule":"THE_PUNCT","sentence":"^\\Q[Albero di copertura dei cammini minimi] [main, line width=1.3pt] (a) [label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (b) [right of=a, label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, xshift=10mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (c) [below of=b, label=below:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, yshift=-10mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (d) [left of=c, label=below:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, xshift=-10mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [->] (a) edge[line width=1.3pt] node[above] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (b) (b) edge[line width=1.3pt] node[right] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (c) (a) edge[line width=1.3pt] node[left] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (d); [-] (d) edge node[below] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (c); [Albero di copertura di peso minimo] [main, line width=1.3pt] (a) [label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (b) [right of=a, label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, xshift=10mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (c) [below of=b, label=below:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, yshift=-10mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (d) [left of=c, label=below:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, xshift=-10mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [->] (a) edge[line width=1.3pt] node[above] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (b) (b) edge[line width=1.3pt] node[right] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (c) (c) edge[line width=1.3pt] node[below] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (d); [-] (a) edge node[left] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q (d); Albero di copertura dei cammini minimi e di peso minimo\\E$"}
{"rule":"MA_MY","sentence":"^\\QPoiché \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, ma dato che \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q è un albero di copertura minimo, vale anche \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QV() - r) do pos[u] = Q.insert(u, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) pos[r] = Q.insert(r, 0) p[r] = 0 while (not Q.isEmpty()) do NODE u = Q.deleteMin() pos[u] = nil foreach (v \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q G.adj(u)) do if (pos[v] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q nil and G.w(u, v) < pos[v].priority) then Q.decrease(pos[v], G.w(u, v)) p[v] = u return p\\E$"}
{"rule":"PRP_VB","sentence":"^\\QI nodi rossi rappresentano il punto in cui il valore di missing arriva a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q per la prima volta nel cammino radice-foglia.\\E$"}
{"rule":"ACCEPT_EXCEPT","sentence":"^\\Qenumeration(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, ITEM[] S, int i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Verifica se \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q contiene una soluzione ammissibile if (accept(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)) Processa la soluzione (e.g. stampa, conta, …) processSolution(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Verifica se \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q contiene una soluzione non ammissibile else if (reject(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)) then return else Calcola l'insieme delle scelte in funzione di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q SET C = choices(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Itera sull'insieme delle scelte foreach (c \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q C) do S[i] = c Chiamata ricorsiva enumeration(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i + 1, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)\\E$"}
{"rule":"ACCEPT_EXCEPT","sentence":"^\\Qboolean enumeration(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, ITEM[] S, int i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Verifica se \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q contiene una soluzione ammissibile if (accept(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)) Processa la soluzione (e.g. stampa, conta, …) processSolution(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) return true Verifica se \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q contiene una soluzione non ammissibile else if (reject(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)) return false else Calcola l'insieme delle scelte in funzione di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q SET C = choices(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Itera sull'insieme delle scelte foreach (c \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q C) do S[i] = c Chiamata ricorsiva if (enumeration(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i + 1, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)) then return true return false\\E$"}
{"rule":"ACCEPT_EXCEPT","sentence":"^\\Qenumeration(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, ITEM[] S, int i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Verifica se \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q contiene una soluzione ammissibile if (accept(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)) Processa la soluzione (e.g. stampa, conta, …) processSolution(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) else Calcola l'insieme delle scelte in funzione di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q SET C = choices(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) Itera sull'insieme delle scelte foreach (c \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q C) do S[i] = c Chiamata ricorsiva enumeration(\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati problema\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, S, i + 1, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qdati parziali\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q)\\E$"}
{"rule":"NON_ANTI_JJ","sentence":"^\\QLe definizione appena enunciata afferma che nel caso in cui, ad esempio, si stia ordinando per anno di corso una lista di studenti già ordinata alfabeticamente, un metodo stabile produce una lista in cui gli alunni dello stesso anno sono ancora in ordine alfabetico, mentre un ordinamento non stabile probabilmente produrrà una lista senza più alcuna traccia del precedente ordinamento.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QData un'istanza, verificare se soddisfa o meno una data proprietà.\\E$"}
{"rule":"THE_PUNCT","sentence":"^\\Q[main] (a) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (c) [below right of=a, line width=1.3pt] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (b) [above right of=c, line width=1.3pt] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (d) [below left of=c, line width=1.3pt] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (e) [below right of=c] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QCrea una coda a priorità con capacità \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q PRIORITYQUEUE PriorityQueue(int n) Restituisce true se la coda a priorità è vuota boolean isEmpty() Restituisce l'elemento minimo di una coda a priorità non vuota ITEM min() Rimuove e restituisce l’elemento minimo di una coda a priorità non vuota deleteMin() Inserisce l'elemento \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q con priorità \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q nella coda a priorità e restituisce un oggetto PRIORITYITEM che identifica \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q all'interno della coda PRIORITYITEM insert(ITEM x, int p) Diminuisce la priorità dell’oggetto identificato da \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q portandola a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q decrease(PRIORITYITEM y, int p) La specifica di una max-priority queue è uguale, ma invece delle operazioni min, deleteMin e decrease ha max, deleteMax e increase.\\E$"}
{"rule":"MA_MY","sentence":"^\\Q[main] (0) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (1) [below left of=0, xshift=-20, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (2) [below right of=0, xshift=20, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (3) [below left of=1, xshift=0, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (4) [below right of=1, xshift=0, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (5) [below left of=2, xshift=0, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (6) [below right of=2, xshift=0, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (7) [below left of=3, xshift=20, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (8) [below right of=3, xshift=-20, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main] (9) [below left of=4, xshift=20, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [-] (0) edge (1) (0) edge (2) (1) edge (3) (1) edge (4) (2) edge (5) (2) edge (6) (3) edge (7) (3) edge (8) (4) edge (9); Albero max-heap Un albero heap non impone un ordinamento totale tra i figli di un nodo, bensì definisce un ordinamento parziale e quindi soddisfa le seguenti tre proprietà: Riflessività: ogni nodo è maggiore o uguale a se stesso; Antisimmetria: se \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q e \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, allora \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; Transitività: se \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q e \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, allora \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; Un ordinamento parziale è una nozione più debole, ma più facile da realizzare.\\E$"}
{"rule":"AI","sentence":"^\\QheapBuild(ITEM[] A, int n) for (i = \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qn/2\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q downto 1) do maxHeapRestore(A, i, n) [main, label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] (0) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main, label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] (1) [below left of=0, xshift=-20, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main, label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] (2) [below right of=0, xshift=20, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main, label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] (3) [below left of=1, xshift=0, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main, label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] (4) [below right of=1, xshift=0, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main, fill=leaf, label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] (5) [below left of=2, xshift=0, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main, fill=leaf, label=\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] (6) [below right of=2, xshift=0, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main, fill=leaf, label=below:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] (7) [below left of=3, xshift=20, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main, fill=leaf, label=below:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] (8) [below right of=3, xshift=-20, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main, fill=leaf, label=below:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] (9) [below left of=4, xshift=20, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [main, fill=leaf, label=below:\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] (10) [below right of=4, xshift=-20, yshift=-20] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [-] (0) edge (1) (0) edge (2) (1) edge (3) (1) edge (4) (2) edge (5) (2) edge (6) (3) edge (7) (3) edge (8) (4) edge (9) (4) edge (10); maxHeapRestore viene applicata solo ai nodi interni Dimostrazione di correttezza.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Qint capacity Dimensione massima della coda int dim Numero di elementi attualmente presenti nella coda PRIORITYQUEUE[] H Vettore heap PRIORITYQUEUE PriorityQueue(int n) PRIORITYQUEUE t = new PRIORITYQUEUE t.capacity = n t.dim = 0 t.\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QH = new PRIORITYITEM[1… n] return t\\E$"}
{"rule":"NE","sentence":"^\\QTutte le operazioni che modificano gli heap ne ripristinano anche le proprietà.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QCrea \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q insiemi \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q MFSET Mfset(int n) Restituisce il rappresentante dell'insieme contenente \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q int find(int x) Unisce gli insiemi che contengono \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q e \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q merge(int x, int y)\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QV()) do foreach (v \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q G.adj(u)) do M.merge(u,v) return M La complessità di questa versione è \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q dove \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q è il numero di invocazioni di merge.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QMFSET Mfset(int n) MFSET t = new MFSET t.parent = new int[1… n] t.rank = new int[1… n] for (i = 1 to n) do t.parent[i] = i t.rank[i] = 1 return t\\E$"}
{"rule":"E_G","sentence":"^\\Qeg.\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qı in 0,...,15 ı = 7 [cell, fill=Dandelion] (ı) at (ı, 0) ;  ı > 2 ı < 12 [cell, fill=leaf] (ı) at (ı, 0) ;  [cell] (ı) at (ı, 0) ;\\E$"}
{"rule":"PRP_VB","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q è la radice; \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q e \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sono radici dei sottoalberi; \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q ed \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sono fratelli; \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q ed \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sono figli di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q è il padre di \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q ed \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; I nodi gialli sono foglie; Gli altri nodi sono nodi interni;\\E$"}
{"rule":"NE","sentence":"^\\QTREE right() return right Ipotizziamo che sia possibile inserire un figlio solo se non ne esiste già uno insertLeft(TREE t) if (left == nil) then t.parent = this left = t\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QdeleteLeft() if (left \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q nil) then left.deleteLeft() left.deleteRight() delete left left = nil deleteRight() if (right \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q nil) then right.deleteLeft() right.deleteRight() delete right right = nil\\E$"}
{"rule":"PRP_VB","sentence":"^\\QI modi sono tre: Vettore dei figli: ogni nodo contiene un riferimento al padre e un vettore contenente i puntatori ai figli; Primo figlio, prossimo fratello: ogni nodo contiene un riferimento al padre e un riferimento al prossimo fratello; Vettore dei padri: l'albero è rappresentato da un vettore di coppie nelle quali il primo valore è il valore associato al nodo e il secondo è l'indice della posizione del padre nel vettore;\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QTREE Tree(ITEM v) TREE t = new TREE t.value = v t.parent = nil t.child = nil t.sibling = nil return t Inserisce \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q prima dell'attuale figlio insertChild(TREE t) t.parent = this t.sibling = child child = t Inserisce \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q prima dell'attuale prossimo fratello insertSibling(TREE t) t.parent = parent t.sibling = sibling sibling = t ITEM read() return value\\E$"}
{"rule":"AI","sentence":"^\\QLa tecnica del Divide-et-impera prevede che il problema da risolvere venga suddiviso in sotto-problemi indipendenti e che le soluzioni ai sotto-problemi vengano combinate per ottenere la soluzione al problema di partenza.\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qn / 5\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] for (i = 1 to \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qn / 5\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) do M[i] = median(A, first + (i - 1) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q 5, last) Individua la mediana delle mediane e la usa come pivot ITEM m = select(M, 1, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qn / 5\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qn / 5\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q / 2\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) int j = pivot(A, first, last, m) int q = j - first + 1 Indice del valore ricercato rispetto al sottovettore if (k == q) then return A[j] else if (k < q) then return selection(A, first, j - 1, k) else return selection(A, j + 1, last, k - q)\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qı in 1,...,15 ı = 5 [separator] (sı) at (ı) ;  ı = 10 [separator] (sı) at (ı,0)+(3mm,0) ;  ı > 4 ı < 11\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qı in 1,...,15 ı = 5 [separator] (sı) at (ı) ;  ı = 10 [separator] (sı) at (ı,0)+(3mm,0) ;  ı > 4 ı < 11 [cell] (ı) at (ı,0)+(3mm,0) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;  ı < 5 [cell] (ı) at (ı,0) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;  [cell] (ı) at (ı,0)+(6mm,0) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qı in 1,...,15 ı = 6 [separator] (sı) at (ı) d;  ı = 11 [separator] (sı) at (ı,0)+(3mm,0) s;  ı < 6 [cell] (ı) at (ı) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;  ı > 5 ı < 11 [cell] (ı) at (ı,0)+(3mm,0) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;  [cell] (ı) at (ı,0)+(6mm,0) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qı in 6,...,10 ı = 8 [cell] (ı) at (ı) [xshift=1mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;  [cell] (ı) at (ı) [xshift=1mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [separator] (s1) at (9) [xshift=15.52mm] ; ı in 11,...,15 ı = 13 [cell] (ı) at (ı) [xshift=2mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;  [cell] (ı) at (ı) [xshift=2mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; La mediana delle mediane è \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q che è anche il mediano dell'intero vettore\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qı in 1,...,5 ı = 3 [cell] (ı) at (ı) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;  [cell] (ı) at (ı) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [separator] (s1) at (5) [xshift=5.52mm] ;\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qı in 1,...,5 ı = 3 [cell] (ı) at (ı) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;  [cell] (ı) at (ı) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [separator] (s1) at (5) [xshift=5.52mm] ; ı in 6,...,10 ı = 8 [cell] (ı) at (ı) [xshift=1mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;  [cell] (ı) at (ı) [xshift=1mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; [separator] (s1) at (9) [xshift=15.52mm] ; ı in 11,...,15 ı = 13 [cell] (ı) at (ı) [xshift=2mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q;  [cell] (ı) at (ı) [xshift=2mm] \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; La mediana delle mediane è \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q che è anche la mediana dell'intero vettore\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qn / 5\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q] for (i = 1 to \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qn / 5\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) do M[i] = median5(A, first + (i - 1) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q 5, last) Individua la mediana delle mediane e la usa come pivot ITEM m = select(M, 1, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qn / 5\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qn / 5\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q / 2\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) int j = pivot(A, first, last, m) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q è il pivot e \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q ne è l'indice int q = j - first + 1 Indice del valore ricercato rispetto al sottovettore if (k == q) then return m else if (k < q) then return select(A, first, j - 1, k) else return select(A, j + 1, last, k - q)\\E$"}
